// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/team19/app/ent/classdate"
	"github.com/team19/app/ent/classroom"
	"github.com/team19/app/ent/classtime"
	"github.com/team19/app/ent/courseclass"
	"github.com/team19/app/ent/instructorinfo"
	"github.com/team19/app/ent/subject"
)

// Courseclass is the model entity for the Courseclass schema.
type Courseclass struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Tablecode holds the value of the "tablecode" field.
	Tablecode string `json:"tablecode,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the CourseclassQuery when eager-loading is set.
	Edges             CourseclassEdges `json:"edges"`
	classdate_id      *int
	classroom_id      *int
	classtime_id      *int
	InstructorInfo_id *int
	subject_id        *int
}

// CourseclassEdges holds the relations/edges for other nodes in the graph.
type CourseclassEdges struct {
	// Classtime holds the value of the classtime edge.
	Classtime *Classtime
	// Classdate holds the value of the classdate edge.
	Classdate *Classdate
	// Classroom holds the value of the classroom edge.
	Classroom *Classroom
	// InstructorInfo holds the value of the instructorInfo edge.
	InstructorInfo *InstructorInfo
	// Subject holds the value of the subject edge.
	Subject *Subject
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// ClasstimeOrErr returns the Classtime value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e CourseclassEdges) ClasstimeOrErr() (*Classtime, error) {
	if e.loadedTypes[0] {
		if e.Classtime == nil {
			// The edge classtime was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: classtime.Label}
		}
		return e.Classtime, nil
	}
	return nil, &NotLoadedError{edge: "classtime"}
}

// ClassdateOrErr returns the Classdate value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e CourseclassEdges) ClassdateOrErr() (*Classdate, error) {
	if e.loadedTypes[1] {
		if e.Classdate == nil {
			// The edge classdate was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: classdate.Label}
		}
		return e.Classdate, nil
	}
	return nil, &NotLoadedError{edge: "classdate"}
}

// ClassroomOrErr returns the Classroom value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e CourseclassEdges) ClassroomOrErr() (*Classroom, error) {
	if e.loadedTypes[2] {
		if e.Classroom == nil {
			// The edge classroom was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: classroom.Label}
		}
		return e.Classroom, nil
	}
	return nil, &NotLoadedError{edge: "classroom"}
}

// InstructorInfoOrErr returns the InstructorInfo value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e CourseclassEdges) InstructorInfoOrErr() (*InstructorInfo, error) {
	if e.loadedTypes[3] {
		if e.InstructorInfo == nil {
			// The edge instructorInfo was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: instructorinfo.Label}
		}
		return e.InstructorInfo, nil
	}
	return nil, &NotLoadedError{edge: "instructorInfo"}
}

// SubjectOrErr returns the Subject value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e CourseclassEdges) SubjectOrErr() (*Subject, error) {
	if e.loadedTypes[4] {
		if e.Subject == nil {
			// The edge subject was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: subject.Label}
		}
		return e.Subject, nil
	}
	return nil, &NotLoadedError{edge: "subject"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Courseclass) scanValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{},  // id
		&sql.NullString{}, // tablecode
	}
}

// fkValues returns the types for scanning foreign-keys values from sql.Rows.
func (*Courseclass) fkValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{}, // classdate_id
		&sql.NullInt64{}, // classroom_id
		&sql.NullInt64{}, // classtime_id
		&sql.NullInt64{}, // InstructorInfo_id
		&sql.NullInt64{}, // subject_id
	}
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Courseclass fields.
func (c *Courseclass) assignValues(values ...interface{}) error {
	if m, n := len(values), len(courseclass.Columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	value, ok := values[0].(*sql.NullInt64)
	if !ok {
		return fmt.Errorf("unexpected type %T for field id", value)
	}
	c.ID = int(value.Int64)
	values = values[1:]
	if value, ok := values[0].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field tablecode", values[0])
	} else if value.Valid {
		c.Tablecode = value.String
	}
	values = values[1:]
	if len(values) == len(courseclass.ForeignKeys) {
		if value, ok := values[0].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field classdate_id", value)
		} else if value.Valid {
			c.classdate_id = new(int)
			*c.classdate_id = int(value.Int64)
		}
		if value, ok := values[1].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field classroom_id", value)
		} else if value.Valid {
			c.classroom_id = new(int)
			*c.classroom_id = int(value.Int64)
		}
		if value, ok := values[2].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field classtime_id", value)
		} else if value.Valid {
			c.classtime_id = new(int)
			*c.classtime_id = int(value.Int64)
		}
		if value, ok := values[3].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field InstructorInfo_id", value)
		} else if value.Valid {
			c.InstructorInfo_id = new(int)
			*c.InstructorInfo_id = int(value.Int64)
		}
		if value, ok := values[4].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field subject_id", value)
		} else if value.Valid {
			c.subject_id = new(int)
			*c.subject_id = int(value.Int64)
		}
	}
	return nil
}

// QueryClasstime queries the classtime edge of the Courseclass.
func (c *Courseclass) QueryClasstime() *ClasstimeQuery {
	return (&CourseclassClient{config: c.config}).QueryClasstime(c)
}

// QueryClassdate queries the classdate edge of the Courseclass.
func (c *Courseclass) QueryClassdate() *ClassdateQuery {
	return (&CourseclassClient{config: c.config}).QueryClassdate(c)
}

// QueryClassroom queries the classroom edge of the Courseclass.
func (c *Courseclass) QueryClassroom() *ClassroomQuery {
	return (&CourseclassClient{config: c.config}).QueryClassroom(c)
}

// QueryInstructorInfo queries the instructorInfo edge of the Courseclass.
func (c *Courseclass) QueryInstructorInfo() *InstructorInfoQuery {
	return (&CourseclassClient{config: c.config}).QueryInstructorInfo(c)
}

// QuerySubject queries the subject edge of the Courseclass.
func (c *Courseclass) QuerySubject() *SubjectQuery {
	return (&CourseclassClient{config: c.config}).QuerySubject(c)
}

// Update returns a builder for updating this Courseclass.
// Note that, you need to call Courseclass.Unwrap() before calling this method, if this Courseclass
// was returned from a transaction, and the transaction was committed or rolled back.
func (c *Courseclass) Update() *CourseclassUpdateOne {
	return (&CourseclassClient{config: c.config}).UpdateOne(c)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (c *Courseclass) Unwrap() *Courseclass {
	tx, ok := c.config.driver.(*txDriver)
	if !ok {
		panic("ent: Courseclass is not a transactional entity")
	}
	c.config.driver = tx.drv
	return c
}

// String implements the fmt.Stringer.
func (c *Courseclass) String() string {
	var builder strings.Builder
	builder.WriteString("Courseclass(")
	builder.WriteString(fmt.Sprintf("id=%v", c.ID))
	builder.WriteString(", tablecode=")
	builder.WriteString(c.Tablecode)
	builder.WriteByte(')')
	return builder.String()
}

// Courseclasses is a parsable slice of Courseclass.
type Courseclasses []*Courseclass

func (c Courseclasses) config(cfg config) {
	for _i := range c {
		c[_i].config = cfg
	}
}
