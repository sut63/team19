// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/team19/app/ent/classdate"
	"github.com/team19/app/ent/classroom"
	"github.com/team19/app/ent/classtime"
	"github.com/team19/app/ent/course"
	"github.com/team19/app/ent/courseclass"
	"github.com/team19/app/ent/degree"
	"github.com/team19/app/ent/department"
	"github.com/team19/app/ent/instructorinfo"
	"github.com/team19/app/ent/instructorroom"
	"github.com/team19/app/ent/subject"
	"github.com/team19/app/ent/subjectsoffered"
	"github.com/team19/app/ent/term"
	"github.com/team19/app/ent/title"
	"github.com/team19/app/ent/year"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClassdate       = "Classdate"
	TypeClassroom       = "Classroom"
	TypeClasstime       = "Classtime"
	TypeCourse          = "Course"
	TypeCourseclass     = "Courseclass"
	TypeDegree          = "Degree"
	TypeDepartment      = "Department"
	TypeInstructorInfo  = "InstructorInfo"
	TypeInstructorRoom  = "InstructorRoom"
	TypeSubject         = "Subject"
	TypeSubjectsOffered = "SubjectsOffered"
	TypeTerm            = "Term"
	TypeTitle           = "Title"
	TypeYear            = "Year"
)

// ClassdateMutation represents an operation that mutate the Classdates
// nodes in the graph.
type ClassdateMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_DAY                 *string
	clearedFields        map[string]struct{}
	courseclasses        map[int]struct{}
	removedcourseclasses map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Classdate, error)
}

var _ ent.Mutation = (*ClassdateMutation)(nil)

// classdateOption allows to manage the mutation configuration using functional options.
type classdateOption func(*ClassdateMutation)

// newClassdateMutation creates new mutation for $n.Name.
func newClassdateMutation(c config, op Op, opts ...classdateOption) *ClassdateMutation {
	m := &ClassdateMutation{
		config:        c,
		op:            op,
		typ:           TypeClassdate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassdateID sets the id field of the mutation.
func withClassdateID(id int) classdateOption {
	return func(m *ClassdateMutation) {
		var (
			err   error
			once  sync.Once
			value *Classdate
		)
		m.oldValue = func(ctx context.Context) (*Classdate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Classdate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassdate sets the old Classdate of the mutation.
func withClassdate(node *Classdate) classdateOption {
	return func(m *ClassdateMutation) {
		m.oldValue = func(context.Context) (*Classdate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassdateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassdateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClassdateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDAY sets the DAY field.
func (m *ClassdateMutation) SetDAY(s string) {
	m._DAY = &s
}

// DAY returns the DAY value in the mutation.
func (m *ClassdateMutation) DAY() (r string, exists bool) {
	v := m._DAY
	if v == nil {
		return
	}
	return *v, true
}

// OldDAY returns the old DAY value of the Classdate.
// If the Classdate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClassdateMutation) OldDAY(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDAY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDAY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDAY: %w", err)
	}
	return oldValue.DAY, nil
}

// ResetDAY reset all changes of the "DAY" field.
func (m *ClassdateMutation) ResetDAY() {
	m._DAY = nil
}

// AddCourseclassIDs adds the courseclasses edge to Courseclass by ids.
func (m *ClassdateMutation) AddCourseclassIDs(ids ...int) {
	if m.courseclasses == nil {
		m.courseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.courseclasses[ids[i]] = struct{}{}
	}
}

// RemoveCourseclassIDs removes the courseclasses edge to Courseclass by ids.
func (m *ClassdateMutation) RemoveCourseclassIDs(ids ...int) {
	if m.removedcourseclasses == nil {
		m.removedcourseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourseclasses[ids[i]] = struct{}{}
	}
}

// RemovedCourseclasses returns the removed ids of courseclasses.
func (m *ClassdateMutation) RemovedCourseclassesIDs() (ids []int) {
	for id := range m.removedcourseclasses {
		ids = append(ids, id)
	}
	return
}

// CourseclassesIDs returns the courseclasses ids in the mutation.
func (m *ClassdateMutation) CourseclassesIDs() (ids []int) {
	for id := range m.courseclasses {
		ids = append(ids, id)
	}
	return
}

// ResetCourseclasses reset all changes of the "courseclasses" edge.
func (m *ClassdateMutation) ResetCourseclasses() {
	m.courseclasses = nil
	m.removedcourseclasses = nil
}

// Op returns the operation name.
func (m *ClassdateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Classdate).
func (m *ClassdateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClassdateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._DAY != nil {
		fields = append(fields, classdate.FieldDAY)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClassdateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classdate.FieldDAY:
		return m.DAY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClassdateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classdate.FieldDAY:
		return m.OldDAY(ctx)
	}
	return nil, fmt.Errorf("unknown Classdate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClassdateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classdate.FieldDAY:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDAY(v)
		return nil
	}
	return fmt.Errorf("unknown Classdate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClassdateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClassdateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClassdateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Classdate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClassdateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClassdateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassdateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Classdate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClassdateMutation) ResetField(name string) error {
	switch name {
	case classdate.FieldDAY:
		m.ResetDAY()
		return nil
	}
	return fmt.Errorf("unknown Classdate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClassdateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.courseclasses != nil {
		edges = append(edges, classdate.EdgeCourseclasses)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClassdateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classdate.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.courseclasses))
		for id := range m.courseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClassdateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourseclasses != nil {
		edges = append(edges, classdate.EdgeCourseclasses)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClassdateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case classdate.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.removedcourseclasses))
		for id := range m.removedcourseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClassdateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClassdateMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClassdateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Classdate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClassdateMutation) ResetEdge(name string) error {
	switch name {
	case classdate.EdgeCourseclasses:
		m.ResetCourseclasses()
		return nil
	}
	return fmt.Errorf("unknown Classdate edge %s", name)
}

// ClassroomMutation represents an operation that mutate the Classrooms
// nodes in the graph.
type ClassroomMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_ROOM                *string
	clearedFields        map[string]struct{}
	courseclasses        map[int]struct{}
	removedcourseclasses map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Classroom, error)
}

var _ ent.Mutation = (*ClassroomMutation)(nil)

// classroomOption allows to manage the mutation configuration using functional options.
type classroomOption func(*ClassroomMutation)

// newClassroomMutation creates new mutation for $n.Name.
func newClassroomMutation(c config, op Op, opts ...classroomOption) *ClassroomMutation {
	m := &ClassroomMutation{
		config:        c,
		op:            op,
		typ:           TypeClassroom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassroomID sets the id field of the mutation.
func withClassroomID(id int) classroomOption {
	return func(m *ClassroomMutation) {
		var (
			err   error
			once  sync.Once
			value *Classroom
		)
		m.oldValue = func(ctx context.Context) (*Classroom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Classroom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassroom sets the old Classroom of the mutation.
func withClassroom(node *Classroom) classroomOption {
	return func(m *ClassroomMutation) {
		m.oldValue = func(context.Context) (*Classroom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassroomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassroomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClassroomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetROOM sets the ROOM field.
func (m *ClassroomMutation) SetROOM(s string) {
	m._ROOM = &s
}

// ROOM returns the ROOM value in the mutation.
func (m *ClassroomMutation) ROOM() (r string, exists bool) {
	v := m._ROOM
	if v == nil {
		return
	}
	return *v, true
}

// OldROOM returns the old ROOM value of the Classroom.
// If the Classroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClassroomMutation) OldROOM(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldROOM is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldROOM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldROOM: %w", err)
	}
	return oldValue.ROOM, nil
}

// ResetROOM reset all changes of the "ROOM" field.
func (m *ClassroomMutation) ResetROOM() {
	m._ROOM = nil
}

// AddCourseclassIDs adds the courseclasses edge to Courseclass by ids.
func (m *ClassroomMutation) AddCourseclassIDs(ids ...int) {
	if m.courseclasses == nil {
		m.courseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.courseclasses[ids[i]] = struct{}{}
	}
}

// RemoveCourseclassIDs removes the courseclasses edge to Courseclass by ids.
func (m *ClassroomMutation) RemoveCourseclassIDs(ids ...int) {
	if m.removedcourseclasses == nil {
		m.removedcourseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourseclasses[ids[i]] = struct{}{}
	}
}

// RemovedCourseclasses returns the removed ids of courseclasses.
func (m *ClassroomMutation) RemovedCourseclassesIDs() (ids []int) {
	for id := range m.removedcourseclasses {
		ids = append(ids, id)
	}
	return
}

// CourseclassesIDs returns the courseclasses ids in the mutation.
func (m *ClassroomMutation) CourseclassesIDs() (ids []int) {
	for id := range m.courseclasses {
		ids = append(ids, id)
	}
	return
}

// ResetCourseclasses reset all changes of the "courseclasses" edge.
func (m *ClassroomMutation) ResetCourseclasses() {
	m.courseclasses = nil
	m.removedcourseclasses = nil
}

// Op returns the operation name.
func (m *ClassroomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Classroom).
func (m *ClassroomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClassroomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._ROOM != nil {
		fields = append(fields, classroom.FieldROOM)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClassroomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classroom.FieldROOM:
		return m.ROOM()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClassroomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classroom.FieldROOM:
		return m.OldROOM(ctx)
	}
	return nil, fmt.Errorf("unknown Classroom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClassroomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classroom.FieldROOM:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetROOM(v)
		return nil
	}
	return fmt.Errorf("unknown Classroom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClassroomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClassroomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClassroomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Classroom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClassroomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClassroomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassroomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Classroom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClassroomMutation) ResetField(name string) error {
	switch name {
	case classroom.FieldROOM:
		m.ResetROOM()
		return nil
	}
	return fmt.Errorf("unknown Classroom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClassroomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.courseclasses != nil {
		edges = append(edges, classroom.EdgeCourseclasses)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClassroomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classroom.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.courseclasses))
		for id := range m.courseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClassroomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourseclasses != nil {
		edges = append(edges, classroom.EdgeCourseclasses)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClassroomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case classroom.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.removedcourseclasses))
		for id := range m.removedcourseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClassroomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClassroomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClassroomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Classroom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClassroomMutation) ResetEdge(name string) error {
	switch name {
	case classroom.EdgeCourseclasses:
		m.ResetCourseclasses()
		return nil
	}
	return fmt.Errorf("unknown Classroom edge %s", name)
}

// ClasstimeMutation represents an operation that mutate the Classtimes
// nodes in the graph.
type ClasstimeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_TIME                *string
	clearedFields        map[string]struct{}
	courseclasses        map[int]struct{}
	removedcourseclasses map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Classtime, error)
}

var _ ent.Mutation = (*ClasstimeMutation)(nil)

// classtimeOption allows to manage the mutation configuration using functional options.
type classtimeOption func(*ClasstimeMutation)

// newClasstimeMutation creates new mutation for $n.Name.
func newClasstimeMutation(c config, op Op, opts ...classtimeOption) *ClasstimeMutation {
	m := &ClasstimeMutation{
		config:        c,
		op:            op,
		typ:           TypeClasstime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClasstimeID sets the id field of the mutation.
func withClasstimeID(id int) classtimeOption {
	return func(m *ClasstimeMutation) {
		var (
			err   error
			once  sync.Once
			value *Classtime
		)
		m.oldValue = func(ctx context.Context) (*Classtime, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Classtime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClasstime sets the old Classtime of the mutation.
func withClasstime(node *Classtime) classtimeOption {
	return func(m *ClasstimeMutation) {
		m.oldValue = func(context.Context) (*Classtime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClasstimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClasstimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClasstimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTIME sets the TIME field.
func (m *ClasstimeMutation) SetTIME(s string) {
	m._TIME = &s
}

// TIME returns the TIME value in the mutation.
func (m *ClasstimeMutation) TIME() (r string, exists bool) {
	v := m._TIME
	if v == nil {
		return
	}
	return *v, true
}

// OldTIME returns the old TIME value of the Classtime.
// If the Classtime object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClasstimeMutation) OldTIME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTIME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTIME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTIME: %w", err)
	}
	return oldValue.TIME, nil
}

// ResetTIME reset all changes of the "TIME" field.
func (m *ClasstimeMutation) ResetTIME() {
	m._TIME = nil
}

// AddCourseclassIDs adds the courseclasses edge to Courseclass by ids.
func (m *ClasstimeMutation) AddCourseclassIDs(ids ...int) {
	if m.courseclasses == nil {
		m.courseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.courseclasses[ids[i]] = struct{}{}
	}
}

// RemoveCourseclassIDs removes the courseclasses edge to Courseclass by ids.
func (m *ClasstimeMutation) RemoveCourseclassIDs(ids ...int) {
	if m.removedcourseclasses == nil {
		m.removedcourseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourseclasses[ids[i]] = struct{}{}
	}
}

// RemovedCourseclasses returns the removed ids of courseclasses.
func (m *ClasstimeMutation) RemovedCourseclassesIDs() (ids []int) {
	for id := range m.removedcourseclasses {
		ids = append(ids, id)
	}
	return
}

// CourseclassesIDs returns the courseclasses ids in the mutation.
func (m *ClasstimeMutation) CourseclassesIDs() (ids []int) {
	for id := range m.courseclasses {
		ids = append(ids, id)
	}
	return
}

// ResetCourseclasses reset all changes of the "courseclasses" edge.
func (m *ClasstimeMutation) ResetCourseclasses() {
	m.courseclasses = nil
	m.removedcourseclasses = nil
}

// Op returns the operation name.
func (m *ClasstimeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Classtime).
func (m *ClasstimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClasstimeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TIME != nil {
		fields = append(fields, classtime.FieldTIME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClasstimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classtime.FieldTIME:
		return m.TIME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClasstimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classtime.FieldTIME:
		return m.OldTIME(ctx)
	}
	return nil, fmt.Errorf("unknown Classtime field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClasstimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classtime.FieldTIME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTIME(v)
		return nil
	}
	return fmt.Errorf("unknown Classtime field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClasstimeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClasstimeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClasstimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Classtime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClasstimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClasstimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClasstimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Classtime nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClasstimeMutation) ResetField(name string) error {
	switch name {
	case classtime.FieldTIME:
		m.ResetTIME()
		return nil
	}
	return fmt.Errorf("unknown Classtime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClasstimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.courseclasses != nil {
		edges = append(edges, classtime.EdgeCourseclasses)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClasstimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case classtime.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.courseclasses))
		for id := range m.courseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClasstimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourseclasses != nil {
		edges = append(edges, classtime.EdgeCourseclasses)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClasstimeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case classtime.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.removedcourseclasses))
		for id := range m.removedcourseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClasstimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClasstimeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClasstimeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Classtime unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClasstimeMutation) ResetEdge(name string) error {
	switch name {
	case classtime.EdgeCourseclasses:
		m.ResetCourseclasses()
		return nil
	}
	return fmt.Errorf("unknown Classtime edge %s", name)
}

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Course_name              *string
	clearedFields             map[string]struct{}
	_InstructorInfo_id        *int
	cleared_InstructorInfo_id bool
	_Department_id            *int
	cleared_Department_id     bool
	_Degree_id                *int
	cleared_Degree_id         bool
	_Subject_id               *int
	cleared_Subject_id        bool
	done                      bool
	oldValue                  func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCourseName sets the Course_name field.
func (m *CourseMutation) SetCourseName(s string) {
	m._Course_name = &s
}

// CourseName returns the Course_name value in the mutation.
func (m *CourseMutation) CourseName() (r string, exists bool) {
	v := m._Course_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseName returns the old Course_name value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldCourseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseName: %w", err)
	}
	return oldValue.CourseName, nil
}

// ResetCourseName reset all changes of the "Course_name" field.
func (m *CourseMutation) ResetCourseName() {
	m._Course_name = nil
}

// SetInstructorInfoIDID sets the InstructorInfo_id edge to InstructorInfo by id.
func (m *CourseMutation) SetInstructorInfoIDID(id int) {
	m._InstructorInfo_id = &id
}

// ClearInstructorInfoID clears the InstructorInfo_id edge to InstructorInfo.
func (m *CourseMutation) ClearInstructorInfoID() {
	m.cleared_InstructorInfo_id = true
}

// InstructorInfoIDCleared returns if the edge InstructorInfo_id was cleared.
func (m *CourseMutation) InstructorInfoIDCleared() bool {
	return m.cleared_InstructorInfo_id
}

// InstructorInfoIDID returns the InstructorInfo_id id in the mutation.
func (m *CourseMutation) InstructorInfoIDID() (id int, exists bool) {
	if m._InstructorInfo_id != nil {
		return *m._InstructorInfo_id, true
	}
	return
}

// InstructorInfoIDIDs returns the InstructorInfo_id ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InstructorInfoIDID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) InstructorInfoIDIDs() (ids []int) {
	if id := m._InstructorInfo_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstructorInfoID reset all changes of the "InstructorInfo_id" edge.
func (m *CourseMutation) ResetInstructorInfoID() {
	m._InstructorInfo_id = nil
	m.cleared_InstructorInfo_id = false
}

// SetDepartmentIDID sets the Department_id edge to Department by id.
func (m *CourseMutation) SetDepartmentIDID(id int) {
	m._Department_id = &id
}

// ClearDepartmentID clears the Department_id edge to Department.
func (m *CourseMutation) ClearDepartmentID() {
	m.cleared_Department_id = true
}

// DepartmentIDCleared returns if the edge Department_id was cleared.
func (m *CourseMutation) DepartmentIDCleared() bool {
	return m.cleared_Department_id
}

// DepartmentIDID returns the Department_id id in the mutation.
func (m *CourseMutation) DepartmentIDID() (id int, exists bool) {
	if m._Department_id != nil {
		return *m._Department_id, true
	}
	return
}

// DepartmentIDIDs returns the Department_id ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentIDID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) DepartmentIDIDs() (ids []int) {
	if id := m._Department_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartmentID reset all changes of the "Department_id" edge.
func (m *CourseMutation) ResetDepartmentID() {
	m._Department_id = nil
	m.cleared_Department_id = false
}

// SetDegreeIDID sets the Degree_id edge to Degree by id.
func (m *CourseMutation) SetDegreeIDID(id int) {
	m._Degree_id = &id
}

// ClearDegreeID clears the Degree_id edge to Degree.
func (m *CourseMutation) ClearDegreeID() {
	m.cleared_Degree_id = true
}

// DegreeIDCleared returns if the edge Degree_id was cleared.
func (m *CourseMutation) DegreeIDCleared() bool {
	return m.cleared_Degree_id
}

// DegreeIDID returns the Degree_id id in the mutation.
func (m *CourseMutation) DegreeIDID() (id int, exists bool) {
	if m._Degree_id != nil {
		return *m._Degree_id, true
	}
	return
}

// DegreeIDIDs returns the Degree_id ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DegreeIDID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) DegreeIDIDs() (ids []int) {
	if id := m._Degree_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDegreeID reset all changes of the "Degree_id" edge.
func (m *CourseMutation) ResetDegreeID() {
	m._Degree_id = nil
	m.cleared_Degree_id = false
}

// SetSubjectIDID sets the Subject_id edge to Subject by id.
func (m *CourseMutation) SetSubjectIDID(id int) {
	m._Subject_id = &id
}

// ClearSubjectID clears the Subject_id edge to Subject.
func (m *CourseMutation) ClearSubjectID() {
	m.cleared_Subject_id = true
}

// SubjectIDCleared returns if the edge Subject_id was cleared.
func (m *CourseMutation) SubjectIDCleared() bool {
	return m.cleared_Subject_id
}

// SubjectIDID returns the Subject_id id in the mutation.
func (m *CourseMutation) SubjectIDID() (id int, exists bool) {
	if m._Subject_id != nil {
		return *m._Subject_id, true
	}
	return
}

// SubjectIDIDs returns the Subject_id ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SubjectIDID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) SubjectIDIDs() (ids []int) {
	if id := m._Subject_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubjectID reset all changes of the "Subject_id" edge.
func (m *CourseMutation) ResetSubjectID() {
	m._Subject_id = nil
	m.cleared_Subject_id = false
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Course_name != nil {
		fields = append(fields, course.FieldCourseName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldCourseName:
		return m.CourseName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldCourseName:
		return m.OldCourseName(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldCourseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseName(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldCourseName:
		m.ResetCourseName()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._InstructorInfo_id != nil {
		edges = append(edges, course.EdgeInstructorInfoID)
	}
	if m._Department_id != nil {
		edges = append(edges, course.EdgeDepartmentID)
	}
	if m._Degree_id != nil {
		edges = append(edges, course.EdgeDegreeID)
	}
	if m._Subject_id != nil {
		edges = append(edges, course.EdgeSubjectID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeInstructorInfoID:
		if id := m._InstructorInfo_id; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeDepartmentID:
		if id := m._Department_id; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeDegreeID:
		if id := m._Degree_id; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeSubjectID:
		if id := m._Subject_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_InstructorInfo_id {
		edges = append(edges, course.EdgeInstructorInfoID)
	}
	if m.cleared_Department_id {
		edges = append(edges, course.EdgeDepartmentID)
	}
	if m.cleared_Degree_id {
		edges = append(edges, course.EdgeDegreeID)
	}
	if m.cleared_Subject_id {
		edges = append(edges, course.EdgeSubjectID)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeInstructorInfoID:
		return m.cleared_InstructorInfo_id
	case course.EdgeDepartmentID:
		return m.cleared_Department_id
	case course.EdgeDegreeID:
		return m.cleared_Degree_id
	case course.EdgeSubjectID:
		return m.cleared_Subject_id
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeInstructorInfoID:
		m.ClearInstructorInfoID()
		return nil
	case course.EdgeDepartmentID:
		m.ClearDepartmentID()
		return nil
	case course.EdgeDegreeID:
		m.ClearDegreeID()
		return nil
	case course.EdgeSubjectID:
		m.ClearSubjectID()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeInstructorInfoID:
		m.ResetInstructorInfoID()
		return nil
	case course.EdgeDepartmentID:
		m.ResetDepartmentID()
		return nil
	case course.EdgeDegreeID:
		m.ResetDegreeID()
		return nil
	case course.EdgeSubjectID:
		m.ResetSubjectID()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// CourseclassMutation represents an operation that mutate the Courseclasses
// nodes in the graph.
type CourseclassMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	clearedFields         map[string]struct{}
	classtime             *int
	clearedclasstime      bool
	classdate             *int
	clearedclassdate      bool
	classroom             *int
	clearedclassroom      bool
	instructorInfo        *int
	clearedinstructorInfo bool
	subject               *int
	clearedsubject        bool
	done                  bool
	oldValue              func(context.Context) (*Courseclass, error)
}

var _ ent.Mutation = (*CourseclassMutation)(nil)

// courseclassOption allows to manage the mutation configuration using functional options.
type courseclassOption func(*CourseclassMutation)

// newCourseclassMutation creates new mutation for $n.Name.
func newCourseclassMutation(c config, op Op, opts ...courseclassOption) *CourseclassMutation {
	m := &CourseclassMutation{
		config:        c,
		op:            op,
		typ:           TypeCourseclass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseclassID sets the id field of the mutation.
func withCourseclassID(id int) courseclassOption {
	return func(m *CourseclassMutation) {
		var (
			err   error
			once  sync.Once
			value *Courseclass
		)
		m.oldValue = func(ctx context.Context) (*Courseclass, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Courseclass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourseclass sets the old Courseclass of the mutation.
func withCourseclass(node *Courseclass) courseclassOption {
	return func(m *CourseclassMutation) {
		m.oldValue = func(context.Context) (*Courseclass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseclassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseclassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseclassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetClasstimeID sets the classtime edge to Classtime by id.
func (m *CourseclassMutation) SetClasstimeID(id int) {
	m.classtime = &id
}

// ClearClasstime clears the classtime edge to Classtime.
func (m *CourseclassMutation) ClearClasstime() {
	m.clearedclasstime = true
}

// ClasstimeCleared returns if the edge classtime was cleared.
func (m *CourseclassMutation) ClasstimeCleared() bool {
	return m.clearedclasstime
}

// ClasstimeID returns the classtime id in the mutation.
func (m *CourseclassMutation) ClasstimeID() (id int, exists bool) {
	if m.classtime != nil {
		return *m.classtime, true
	}
	return
}

// ClasstimeIDs returns the classtime ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClasstimeID instead. It exists only for internal usage by the builders.
func (m *CourseclassMutation) ClasstimeIDs() (ids []int) {
	if id := m.classtime; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClasstime reset all changes of the "classtime" edge.
func (m *CourseclassMutation) ResetClasstime() {
	m.classtime = nil
	m.clearedclasstime = false
}

// SetClassdateID sets the classdate edge to Classdate by id.
func (m *CourseclassMutation) SetClassdateID(id int) {
	m.classdate = &id
}

// ClearClassdate clears the classdate edge to Classdate.
func (m *CourseclassMutation) ClearClassdate() {
	m.clearedclassdate = true
}

// ClassdateCleared returns if the edge classdate was cleared.
func (m *CourseclassMutation) ClassdateCleared() bool {
	return m.clearedclassdate
}

// ClassdateID returns the classdate id in the mutation.
func (m *CourseclassMutation) ClassdateID() (id int, exists bool) {
	if m.classdate != nil {
		return *m.classdate, true
	}
	return
}

// ClassdateIDs returns the classdate ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClassdateID instead. It exists only for internal usage by the builders.
func (m *CourseclassMutation) ClassdateIDs() (ids []int) {
	if id := m.classdate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassdate reset all changes of the "classdate" edge.
func (m *CourseclassMutation) ResetClassdate() {
	m.classdate = nil
	m.clearedclassdate = false
}

// SetClassroomID sets the classroom edge to Classroom by id.
func (m *CourseclassMutation) SetClassroomID(id int) {
	m.classroom = &id
}

// ClearClassroom clears the classroom edge to Classroom.
func (m *CourseclassMutation) ClearClassroom() {
	m.clearedclassroom = true
}

// ClassroomCleared returns if the edge classroom was cleared.
func (m *CourseclassMutation) ClassroomCleared() bool {
	return m.clearedclassroom
}

// ClassroomID returns the classroom id in the mutation.
func (m *CourseclassMutation) ClassroomID() (id int, exists bool) {
	if m.classroom != nil {
		return *m.classroom, true
	}
	return
}

// ClassroomIDs returns the classroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClassroomID instead. It exists only for internal usage by the builders.
func (m *CourseclassMutation) ClassroomIDs() (ids []int) {
	if id := m.classroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClassroom reset all changes of the "classroom" edge.
func (m *CourseclassMutation) ResetClassroom() {
	m.classroom = nil
	m.clearedclassroom = false
}

// SetInstructorInfoID sets the instructorInfo edge to InstructorInfo by id.
func (m *CourseclassMutation) SetInstructorInfoID(id int) {
	m.instructorInfo = &id
}

// ClearInstructorInfo clears the instructorInfo edge to InstructorInfo.
func (m *CourseclassMutation) ClearInstructorInfo() {
	m.clearedinstructorInfo = true
}

// InstructorInfoCleared returns if the edge instructorInfo was cleared.
func (m *CourseclassMutation) InstructorInfoCleared() bool {
	return m.clearedinstructorInfo
}

// InstructorInfoID returns the instructorInfo id in the mutation.
func (m *CourseclassMutation) InstructorInfoID() (id int, exists bool) {
	if m.instructorInfo != nil {
		return *m.instructorInfo, true
	}
	return
}

// InstructorInfoIDs returns the instructorInfo ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InstructorInfoID instead. It exists only for internal usage by the builders.
func (m *CourseclassMutation) InstructorInfoIDs() (ids []int) {
	if id := m.instructorInfo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstructorInfo reset all changes of the "instructorInfo" edge.
func (m *CourseclassMutation) ResetInstructorInfo() {
	m.instructorInfo = nil
	m.clearedinstructorInfo = false
}

// SetSubjectID sets the subject edge to Subject by id.
func (m *CourseclassMutation) SetSubjectID(id int) {
	m.subject = &id
}

// ClearSubject clears the subject edge to Subject.
func (m *CourseclassMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared returns if the edge subject was cleared.
func (m *CourseclassMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectID returns the subject id in the mutation.
func (m *CourseclassMutation) SubjectID() (id int, exists bool) {
	if m.subject != nil {
		return *m.subject, true
	}
	return
}

// SubjectIDs returns the subject ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *CourseclassMutation) SubjectIDs() (ids []int) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject reset all changes of the "subject" edge.
func (m *CourseclassMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// Op returns the operation name.
func (m *CourseclassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Courseclass).
func (m *CourseclassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseclassMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseclassMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseclassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Courseclass field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseclassMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Courseclass field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseclassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseclassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseclassMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Courseclass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseclassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseclassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseclassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Courseclass nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseclassMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Courseclass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseclassMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.classtime != nil {
		edges = append(edges, courseclass.EdgeClasstime)
	}
	if m.classdate != nil {
		edges = append(edges, courseclass.EdgeClassdate)
	}
	if m.classroom != nil {
		edges = append(edges, courseclass.EdgeClassroom)
	}
	if m.instructorInfo != nil {
		edges = append(edges, courseclass.EdgeInstructorInfo)
	}
	if m.subject != nil {
		edges = append(edges, courseclass.EdgeSubject)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseclassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case courseclass.EdgeClasstime:
		if id := m.classtime; id != nil {
			return []ent.Value{*id}
		}
	case courseclass.EdgeClassdate:
		if id := m.classdate; id != nil {
			return []ent.Value{*id}
		}
	case courseclass.EdgeClassroom:
		if id := m.classroom; id != nil {
			return []ent.Value{*id}
		}
	case courseclass.EdgeInstructorInfo:
		if id := m.instructorInfo; id != nil {
			return []ent.Value{*id}
		}
	case courseclass.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseclassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseclassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseclassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedclasstime {
		edges = append(edges, courseclass.EdgeClasstime)
	}
	if m.clearedclassdate {
		edges = append(edges, courseclass.EdgeClassdate)
	}
	if m.clearedclassroom {
		edges = append(edges, courseclass.EdgeClassroom)
	}
	if m.clearedinstructorInfo {
		edges = append(edges, courseclass.EdgeInstructorInfo)
	}
	if m.clearedsubject {
		edges = append(edges, courseclass.EdgeSubject)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseclassMutation) EdgeCleared(name string) bool {
	switch name {
	case courseclass.EdgeClasstime:
		return m.clearedclasstime
	case courseclass.EdgeClassdate:
		return m.clearedclassdate
	case courseclass.EdgeClassroom:
		return m.clearedclassroom
	case courseclass.EdgeInstructorInfo:
		return m.clearedinstructorInfo
	case courseclass.EdgeSubject:
		return m.clearedsubject
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseclassMutation) ClearEdge(name string) error {
	switch name {
	case courseclass.EdgeClasstime:
		m.ClearClasstime()
		return nil
	case courseclass.EdgeClassdate:
		m.ClearClassdate()
		return nil
	case courseclass.EdgeClassroom:
		m.ClearClassroom()
		return nil
	case courseclass.EdgeInstructorInfo:
		m.ClearInstructorInfo()
		return nil
	case courseclass.EdgeSubject:
		m.ClearSubject()
		return nil
	}
	return fmt.Errorf("unknown Courseclass unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseclassMutation) ResetEdge(name string) error {
	switch name {
	case courseclass.EdgeClasstime:
		m.ResetClasstime()
		return nil
	case courseclass.EdgeClassdate:
		m.ResetClassdate()
		return nil
	case courseclass.EdgeClassroom:
		m.ResetClassroom()
		return nil
	case courseclass.EdgeInstructorInfo:
		m.ResetInstructorInfo()
		return nil
	case courseclass.EdgeSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown Courseclass edge %s", name)
}

// DegreeMutation represents an operation that mutate the Degrees
// nodes in the graph.
type DegreeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_Degree_name            *string
	clearedFields           map[string]struct{}
	degree                  map[int]struct{}
	removeddegree           map[int]struct{}
	_SubjectsOffered        map[int]struct{}
	removed_SubjectsOffered map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Degree, error)
}

var _ ent.Mutation = (*DegreeMutation)(nil)

// degreeOption allows to manage the mutation configuration using functional options.
type degreeOption func(*DegreeMutation)

// newDegreeMutation creates new mutation for $n.Name.
func newDegreeMutation(c config, op Op, opts ...degreeOption) *DegreeMutation {
	m := &DegreeMutation{
		config:        c,
		op:            op,
		typ:           TypeDegree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDegreeID sets the id field of the mutation.
func withDegreeID(id int) degreeOption {
	return func(m *DegreeMutation) {
		var (
			err   error
			once  sync.Once
			value *Degree
		)
		m.oldValue = func(ctx context.Context) (*Degree, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Degree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDegree sets the old Degree of the mutation.
func withDegree(node *Degree) degreeOption {
	return func(m *DegreeMutation) {
		m.oldValue = func(context.Context) (*Degree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DegreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DegreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DegreeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDegreeName sets the Degree_name field.
func (m *DegreeMutation) SetDegreeName(s string) {
	m._Degree_name = &s
}

// DegreeName returns the Degree_name value in the mutation.
func (m *DegreeMutation) DegreeName() (r string, exists bool) {
	v := m._Degree_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDegreeName returns the old Degree_name value of the Degree.
// If the Degree object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DegreeMutation) OldDegreeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDegreeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDegreeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegreeName: %w", err)
	}
	return oldValue.DegreeName, nil
}

// ResetDegreeName reset all changes of the "Degree_name" field.
func (m *DegreeMutation) ResetDegreeName() {
	m._Degree_name = nil
}

// AddDegreeIDs adds the degree edge to Course by ids.
func (m *DegreeMutation) AddDegreeIDs(ids ...int) {
	if m.degree == nil {
		m.degree = make(map[int]struct{})
	}
	for i := range ids {
		m.degree[ids[i]] = struct{}{}
	}
}

// RemoveDegreeIDs removes the degree edge to Course by ids.
func (m *DegreeMutation) RemoveDegreeIDs(ids ...int) {
	if m.removeddegree == nil {
		m.removeddegree = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddegree[ids[i]] = struct{}{}
	}
}

// RemovedDegree returns the removed ids of degree.
func (m *DegreeMutation) RemovedDegreeIDs() (ids []int) {
	for id := range m.removeddegree {
		ids = append(ids, id)
	}
	return
}

// DegreeIDs returns the degree ids in the mutation.
func (m *DegreeMutation) DegreeIDs() (ids []int) {
	for id := range m.degree {
		ids = append(ids, id)
	}
	return
}

// ResetDegree reset all changes of the "degree" edge.
func (m *DegreeMutation) ResetDegree() {
	m.degree = nil
	m.removeddegree = nil
}

// AddSubjectsOfferedIDs adds the SubjectsOffered edge to SubjectsOffered by ids.
func (m *DegreeMutation) AddSubjectsOfferedIDs(ids ...int) {
	if m._SubjectsOffered == nil {
		m._SubjectsOffered = make(map[int]struct{})
	}
	for i := range ids {
		m._SubjectsOffered[ids[i]] = struct{}{}
	}
}

// RemoveSubjectsOfferedIDs removes the SubjectsOffered edge to SubjectsOffered by ids.
func (m *DegreeMutation) RemoveSubjectsOfferedIDs(ids ...int) {
	if m.removed_SubjectsOffered == nil {
		m.removed_SubjectsOffered = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_SubjectsOffered[ids[i]] = struct{}{}
	}
}

// RemovedSubjectsOffered returns the removed ids of SubjectsOffered.
func (m *DegreeMutation) RemovedSubjectsOfferedIDs() (ids []int) {
	for id := range m.removed_SubjectsOffered {
		ids = append(ids, id)
	}
	return
}

// SubjectsOfferedIDs returns the SubjectsOffered ids in the mutation.
func (m *DegreeMutation) SubjectsOfferedIDs() (ids []int) {
	for id := range m._SubjectsOffered {
		ids = append(ids, id)
	}
	return
}

// ResetSubjectsOffered reset all changes of the "SubjectsOffered" edge.
func (m *DegreeMutation) ResetSubjectsOffered() {
	m._SubjectsOffered = nil
	m.removed_SubjectsOffered = nil
}

// Op returns the operation name.
func (m *DegreeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Degree).
func (m *DegreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DegreeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Degree_name != nil {
		fields = append(fields, degree.FieldDegreeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DegreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case degree.FieldDegreeName:
		return m.DegreeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DegreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case degree.FieldDegreeName:
		return m.OldDegreeName(ctx)
	}
	return nil, fmt.Errorf("unknown Degree field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DegreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case degree.FieldDegreeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegreeName(v)
		return nil
	}
	return fmt.Errorf("unknown Degree field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DegreeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DegreeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DegreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Degree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DegreeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DegreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DegreeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Degree nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DegreeMutation) ResetField(name string) error {
	switch name {
	case degree.FieldDegreeName:
		m.ResetDegreeName()
		return nil
	}
	return fmt.Errorf("unknown Degree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DegreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.degree != nil {
		edges = append(edges, degree.EdgeDegree)
	}
	if m._SubjectsOffered != nil {
		edges = append(edges, degree.EdgeSubjectsOffered)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DegreeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case degree.EdgeDegree:
		ids := make([]ent.Value, 0, len(m.degree))
		for id := range m.degree {
			ids = append(ids, id)
		}
		return ids
	case degree.EdgeSubjectsOffered:
		ids := make([]ent.Value, 0, len(m._SubjectsOffered))
		for id := range m._SubjectsOffered {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DegreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddegree != nil {
		edges = append(edges, degree.EdgeDegree)
	}
	if m.removed_SubjectsOffered != nil {
		edges = append(edges, degree.EdgeSubjectsOffered)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DegreeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case degree.EdgeDegree:
		ids := make([]ent.Value, 0, len(m.removeddegree))
		for id := range m.removeddegree {
			ids = append(ids, id)
		}
		return ids
	case degree.EdgeSubjectsOffered:
		ids := make([]ent.Value, 0, len(m.removed_SubjectsOffered))
		for id := range m.removed_SubjectsOffered {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DegreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DegreeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DegreeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Degree unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DegreeMutation) ResetEdge(name string) error {
	switch name {
	case degree.EdgeDegree:
		m.ResetDegree()
		return nil
	case degree.EdgeSubjectsOffered:
		m.ResetSubjectsOffered()
		return nil
	}
	return fmt.Errorf("unknown Degree edge %s", name)
}

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_DEPARTMENT            *string
	_FACULTY               *string
	clearedFields          map[string]struct{}
	instructorinfos        map[int]struct{}
	removedinstructorinfos map[int]struct{}
	department             map[int]struct{}
	removeddepartment      map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDEPARTMENT sets the DEPARTMENT field.
func (m *DepartmentMutation) SetDEPARTMENT(s string) {
	m._DEPARTMENT = &s
}

// DEPARTMENT returns the DEPARTMENT value in the mutation.
func (m *DepartmentMutation) DEPARTMENT() (r string, exists bool) {
	v := m._DEPARTMENT
	if v == nil {
		return
	}
	return *v, true
}

// OldDEPARTMENT returns the old DEPARTMENT value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldDEPARTMENT(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDEPARTMENT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDEPARTMENT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDEPARTMENT: %w", err)
	}
	return oldValue.DEPARTMENT, nil
}

// ResetDEPARTMENT reset all changes of the "DEPARTMENT" field.
func (m *DepartmentMutation) ResetDEPARTMENT() {
	m._DEPARTMENT = nil
}

// SetFACULTY sets the FACULTY field.
func (m *DepartmentMutation) SetFACULTY(s string) {
	m._FACULTY = &s
}

// FACULTY returns the FACULTY value in the mutation.
func (m *DepartmentMutation) FACULTY() (r string, exists bool) {
	v := m._FACULTY
	if v == nil {
		return
	}
	return *v, true
}

// OldFACULTY returns the old FACULTY value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldFACULTY(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFACULTY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFACULTY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFACULTY: %w", err)
	}
	return oldValue.FACULTY, nil
}

// ResetFACULTY reset all changes of the "FACULTY" field.
func (m *DepartmentMutation) ResetFACULTY() {
	m._FACULTY = nil
}

// AddInstructorinfoIDs adds the instructorinfos edge to InstructorInfo by ids.
func (m *DepartmentMutation) AddInstructorinfoIDs(ids ...int) {
	if m.instructorinfos == nil {
		m.instructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.instructorinfos[ids[i]] = struct{}{}
	}
}

// RemoveInstructorinfoIDs removes the instructorinfos edge to InstructorInfo by ids.
func (m *DepartmentMutation) RemoveInstructorinfoIDs(ids ...int) {
	if m.removedinstructorinfos == nil {
		m.removedinstructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstructorinfos[ids[i]] = struct{}{}
	}
}

// RemovedInstructorinfos returns the removed ids of instructorinfos.
func (m *DepartmentMutation) RemovedInstructorinfosIDs() (ids []int) {
	for id := range m.removedinstructorinfos {
		ids = append(ids, id)
	}
	return
}

// InstructorinfosIDs returns the instructorinfos ids in the mutation.
func (m *DepartmentMutation) InstructorinfosIDs() (ids []int) {
	for id := range m.instructorinfos {
		ids = append(ids, id)
	}
	return
}

// ResetInstructorinfos reset all changes of the "instructorinfos" edge.
func (m *DepartmentMutation) ResetInstructorinfos() {
	m.instructorinfos = nil
	m.removedinstructorinfos = nil
}

// AddDepartmentIDs adds the department edge to Course by ids.
func (m *DepartmentMutation) AddDepartmentIDs(ids ...int) {
	if m.department == nil {
		m.department = make(map[int]struct{})
	}
	for i := range ids {
		m.department[ids[i]] = struct{}{}
	}
}

// RemoveDepartmentIDs removes the department edge to Course by ids.
func (m *DepartmentMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartment == nil {
		m.removeddepartment = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartment[ids[i]] = struct{}{}
	}
}

// RemovedDepartment returns the removed ids of department.
func (m *DepartmentMutation) RemovedDepartmentIDs() (ids []int) {
	for id := range m.removeddepartment {
		ids = append(ids, id)
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
func (m *DepartmentMutation) DepartmentIDs() (ids []int) {
	for id := range m.department {
		ids = append(ids, id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *DepartmentMutation) ResetDepartment() {
	m.department = nil
	m.removeddepartment = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._DEPARTMENT != nil {
		fields = append(fields, department.FieldDEPARTMENT)
	}
	if m._FACULTY != nil {
		fields = append(fields, department.FieldFACULTY)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDEPARTMENT:
		return m.DEPARTMENT()
	case department.FieldFACULTY:
		return m.FACULTY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDEPARTMENT:
		return m.OldDEPARTMENT(ctx)
	case department.FieldFACULTY:
		return m.OldFACULTY(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDEPARTMENT:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDEPARTMENT(v)
		return nil
	case department.FieldFACULTY:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFACULTY(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDEPARTMENT:
		m.ResetDEPARTMENT()
		return nil
	case department.FieldFACULTY:
		m.ResetFACULTY()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.instructorinfos != nil {
		edges = append(edges, department.EdgeInstructorinfos)
	}
	if m.department != nil {
		edges = append(edges, department.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.instructorinfos))
		for id := range m.instructorinfos {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeDepartment:
		ids := make([]ent.Value, 0, len(m.department))
		for id := range m.department {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinstructorinfos != nil {
		edges = append(edges, department.EdgeInstructorinfos)
	}
	if m.removeddepartment != nil {
		edges = append(edges, department.EdgeDepartment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.removedinstructorinfos))
		for id := range m.removedinstructorinfos {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeDepartment:
		ids := make([]ent.Value, 0, len(m.removeddepartment))
		for id := range m.removeddepartment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeInstructorinfos:
		m.ResetInstructorinfos()
		return nil
	case department.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// InstructorInfoMutation represents an operation that mutate the InstructorInfos
// nodes in the graph.
type InstructorInfoMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	_NAME                 *string
	_PHONENUMBER          *string
	_EMAIL                *string
	_PASSWORD             *string
	clearedFields         map[string]struct{}
	title                 *int
	clearedtitle          bool
	instructorroom        *int
	clearedinstructorroom bool
	department            *int
	cleareddepartment     bool
	instructor            map[int]struct{}
	removedinstructor     map[int]struct{}
	courseclasses         map[int]struct{}
	removedcourseclasses  map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*InstructorInfo, error)
}

var _ ent.Mutation = (*InstructorInfoMutation)(nil)

// instructorinfoOption allows to manage the mutation configuration using functional options.
type instructorinfoOption func(*InstructorInfoMutation)

// newInstructorInfoMutation creates new mutation for $n.Name.
func newInstructorInfoMutation(c config, op Op, opts ...instructorinfoOption) *InstructorInfoMutation {
	m := &InstructorInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeInstructorInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstructorInfoID sets the id field of the mutation.
func withInstructorInfoID(id int) instructorinfoOption {
	return func(m *InstructorInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *InstructorInfo
		)
		m.oldValue = func(ctx context.Context) (*InstructorInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstructorInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstructorInfo sets the old InstructorInfo of the mutation.
func withInstructorInfo(node *InstructorInfo) instructorinfoOption {
	return func(m *InstructorInfoMutation) {
		m.oldValue = func(context.Context) (*InstructorInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstructorInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstructorInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InstructorInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNAME sets the NAME field.
func (m *InstructorInfoMutation) SetNAME(s string) {
	m._NAME = &s
}

// NAME returns the NAME value in the mutation.
func (m *InstructorInfoMutation) NAME() (r string, exists bool) {
	v := m._NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldNAME returns the old NAME value of the InstructorInfo.
// If the InstructorInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorInfoMutation) OldNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNAME: %w", err)
	}
	return oldValue.NAME, nil
}

// ResetNAME reset all changes of the "NAME" field.
func (m *InstructorInfoMutation) ResetNAME() {
	m._NAME = nil
}

// SetPHONENUMBER sets the PHONENUMBER field.
func (m *InstructorInfoMutation) SetPHONENUMBER(s string) {
	m._PHONENUMBER = &s
}

// PHONENUMBER returns the PHONENUMBER value in the mutation.
func (m *InstructorInfoMutation) PHONENUMBER() (r string, exists bool) {
	v := m._PHONENUMBER
	if v == nil {
		return
	}
	return *v, true
}

// OldPHONENUMBER returns the old PHONENUMBER value of the InstructorInfo.
// If the InstructorInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorInfoMutation) OldPHONENUMBER(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPHONENUMBER is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPHONENUMBER requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHONENUMBER: %w", err)
	}
	return oldValue.PHONENUMBER, nil
}

// ResetPHONENUMBER reset all changes of the "PHONENUMBER" field.
func (m *InstructorInfoMutation) ResetPHONENUMBER() {
	m._PHONENUMBER = nil
}

// SetEMAIL sets the EMAIL field.
func (m *InstructorInfoMutation) SetEMAIL(s string) {
	m._EMAIL = &s
}

// EMAIL returns the EMAIL value in the mutation.
func (m *InstructorInfoMutation) EMAIL() (r string, exists bool) {
	v := m._EMAIL
	if v == nil {
		return
	}
	return *v, true
}

// OldEMAIL returns the old EMAIL value of the InstructorInfo.
// If the InstructorInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorInfoMutation) OldEMAIL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEMAIL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEMAIL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEMAIL: %w", err)
	}
	return oldValue.EMAIL, nil
}

// ResetEMAIL reset all changes of the "EMAIL" field.
func (m *InstructorInfoMutation) ResetEMAIL() {
	m._EMAIL = nil
}

// SetPASSWORD sets the PASSWORD field.
func (m *InstructorInfoMutation) SetPASSWORD(s string) {
	m._PASSWORD = &s
}

// PASSWORD returns the PASSWORD value in the mutation.
func (m *InstructorInfoMutation) PASSWORD() (r string, exists bool) {
	v := m._PASSWORD
	if v == nil {
		return
	}
	return *v, true
}

// OldPASSWORD returns the old PASSWORD value of the InstructorInfo.
// If the InstructorInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorInfoMutation) OldPASSWORD(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPASSWORD is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPASSWORD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPASSWORD: %w", err)
	}
	return oldValue.PASSWORD, nil
}

// ResetPASSWORD reset all changes of the "PASSWORD" field.
func (m *InstructorInfoMutation) ResetPASSWORD() {
	m._PASSWORD = nil
}

// SetTitleID sets the title edge to Title by id.
func (m *InstructorInfoMutation) SetTitleID(id int) {
	m.title = &id
}

// ClearTitle clears the title edge to Title.
func (m *InstructorInfoMutation) ClearTitle() {
	m.clearedtitle = true
}

// TitleCleared returns if the edge title was cleared.
func (m *InstructorInfoMutation) TitleCleared() bool {
	return m.clearedtitle
}

// TitleID returns the title id in the mutation.
func (m *InstructorInfoMutation) TitleID() (id int, exists bool) {
	if m.title != nil {
		return *m.title, true
	}
	return
}

// TitleIDs returns the title ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TitleID instead. It exists only for internal usage by the builders.
func (m *InstructorInfoMutation) TitleIDs() (ids []int) {
	if id := m.title; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTitle reset all changes of the "title" edge.
func (m *InstructorInfoMutation) ResetTitle() {
	m.title = nil
	m.clearedtitle = false
}

// SetInstructorroomID sets the instructorroom edge to InstructorRoom by id.
func (m *InstructorInfoMutation) SetInstructorroomID(id int) {
	m.instructorroom = &id
}

// ClearInstructorroom clears the instructorroom edge to InstructorRoom.
func (m *InstructorInfoMutation) ClearInstructorroom() {
	m.clearedinstructorroom = true
}

// InstructorroomCleared returns if the edge instructorroom was cleared.
func (m *InstructorInfoMutation) InstructorroomCleared() bool {
	return m.clearedinstructorroom
}

// InstructorroomID returns the instructorroom id in the mutation.
func (m *InstructorInfoMutation) InstructorroomID() (id int, exists bool) {
	if m.instructorroom != nil {
		return *m.instructorroom, true
	}
	return
}

// InstructorroomIDs returns the instructorroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InstructorroomID instead. It exists only for internal usage by the builders.
func (m *InstructorInfoMutation) InstructorroomIDs() (ids []int) {
	if id := m.instructorroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstructorroom reset all changes of the "instructorroom" edge.
func (m *InstructorInfoMutation) ResetInstructorroom() {
	m.instructorroom = nil
	m.clearedinstructorroom = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *InstructorInfoMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *InstructorInfoMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *InstructorInfoMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *InstructorInfoMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *InstructorInfoMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *InstructorInfoMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddInstructorIDs adds the instructor edge to Course by ids.
func (m *InstructorInfoMutation) AddInstructorIDs(ids ...int) {
	if m.instructor == nil {
		m.instructor = make(map[int]struct{})
	}
	for i := range ids {
		m.instructor[ids[i]] = struct{}{}
	}
}

// RemoveInstructorIDs removes the instructor edge to Course by ids.
func (m *InstructorInfoMutation) RemoveInstructorIDs(ids ...int) {
	if m.removedinstructor == nil {
		m.removedinstructor = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstructor[ids[i]] = struct{}{}
	}
}

// RemovedInstructor returns the removed ids of instructor.
func (m *InstructorInfoMutation) RemovedInstructorIDs() (ids []int) {
	for id := range m.removedinstructor {
		ids = append(ids, id)
	}
	return
}

// InstructorIDs returns the instructor ids in the mutation.
func (m *InstructorInfoMutation) InstructorIDs() (ids []int) {
	for id := range m.instructor {
		ids = append(ids, id)
	}
	return
}

// ResetInstructor reset all changes of the "instructor" edge.
func (m *InstructorInfoMutation) ResetInstructor() {
	m.instructor = nil
	m.removedinstructor = nil
}

// AddCourseclassIDs adds the courseclasses edge to Courseclass by ids.
func (m *InstructorInfoMutation) AddCourseclassIDs(ids ...int) {
	if m.courseclasses == nil {
		m.courseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.courseclasses[ids[i]] = struct{}{}
	}
}

// RemoveCourseclassIDs removes the courseclasses edge to Courseclass by ids.
func (m *InstructorInfoMutation) RemoveCourseclassIDs(ids ...int) {
	if m.removedcourseclasses == nil {
		m.removedcourseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourseclasses[ids[i]] = struct{}{}
	}
}

// RemovedCourseclasses returns the removed ids of courseclasses.
func (m *InstructorInfoMutation) RemovedCourseclassesIDs() (ids []int) {
	for id := range m.removedcourseclasses {
		ids = append(ids, id)
	}
	return
}

// CourseclassesIDs returns the courseclasses ids in the mutation.
func (m *InstructorInfoMutation) CourseclassesIDs() (ids []int) {
	for id := range m.courseclasses {
		ids = append(ids, id)
	}
	return
}

// ResetCourseclasses reset all changes of the "courseclasses" edge.
func (m *InstructorInfoMutation) ResetCourseclasses() {
	m.courseclasses = nil
	m.removedcourseclasses = nil
}

// Op returns the operation name.
func (m *InstructorInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InstructorInfo).
func (m *InstructorInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InstructorInfoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._NAME != nil {
		fields = append(fields, instructorinfo.FieldNAME)
	}
	if m._PHONENUMBER != nil {
		fields = append(fields, instructorinfo.FieldPHONENUMBER)
	}
	if m._EMAIL != nil {
		fields = append(fields, instructorinfo.FieldEMAIL)
	}
	if m._PASSWORD != nil {
		fields = append(fields, instructorinfo.FieldPASSWORD)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InstructorInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instructorinfo.FieldNAME:
		return m.NAME()
	case instructorinfo.FieldPHONENUMBER:
		return m.PHONENUMBER()
	case instructorinfo.FieldEMAIL:
		return m.EMAIL()
	case instructorinfo.FieldPASSWORD:
		return m.PASSWORD()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InstructorInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instructorinfo.FieldNAME:
		return m.OldNAME(ctx)
	case instructorinfo.FieldPHONENUMBER:
		return m.OldPHONENUMBER(ctx)
	case instructorinfo.FieldEMAIL:
		return m.OldEMAIL(ctx)
	case instructorinfo.FieldPASSWORD:
		return m.OldPASSWORD(ctx)
	}
	return nil, fmt.Errorf("unknown InstructorInfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstructorInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instructorinfo.FieldNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNAME(v)
		return nil
	case instructorinfo.FieldPHONENUMBER:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHONENUMBER(v)
		return nil
	case instructorinfo.FieldEMAIL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEMAIL(v)
		return nil
	case instructorinfo.FieldPASSWORD:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPASSWORD(v)
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InstructorInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InstructorInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstructorInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InstructorInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InstructorInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InstructorInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstructorInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InstructorInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InstructorInfoMutation) ResetField(name string) error {
	switch name {
	case instructorinfo.FieldNAME:
		m.ResetNAME()
		return nil
	case instructorinfo.FieldPHONENUMBER:
		m.ResetPHONENUMBER()
		return nil
	case instructorinfo.FieldEMAIL:
		m.ResetEMAIL()
		return nil
	case instructorinfo.FieldPASSWORD:
		m.ResetPASSWORD()
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InstructorInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.title != nil {
		edges = append(edges, instructorinfo.EdgeTitle)
	}
	if m.instructorroom != nil {
		edges = append(edges, instructorinfo.EdgeInstructorroom)
	}
	if m.department != nil {
		edges = append(edges, instructorinfo.EdgeDepartment)
	}
	if m.instructor != nil {
		edges = append(edges, instructorinfo.EdgeInstructor)
	}
	if m.courseclasses != nil {
		edges = append(edges, instructorinfo.EdgeCourseclasses)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InstructorInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instructorinfo.EdgeTitle:
		if id := m.title; id != nil {
			return []ent.Value{*id}
		}
	case instructorinfo.EdgeInstructorroom:
		if id := m.instructorroom; id != nil {
			return []ent.Value{*id}
		}
	case instructorinfo.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case instructorinfo.EdgeInstructor:
		ids := make([]ent.Value, 0, len(m.instructor))
		for id := range m.instructor {
			ids = append(ids, id)
		}
		return ids
	case instructorinfo.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.courseclasses))
		for id := range m.courseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InstructorInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedinstructor != nil {
		edges = append(edges, instructorinfo.EdgeInstructor)
	}
	if m.removedcourseclasses != nil {
		edges = append(edges, instructorinfo.EdgeCourseclasses)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InstructorInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instructorinfo.EdgeInstructor:
		ids := make([]ent.Value, 0, len(m.removedinstructor))
		for id := range m.removedinstructor {
			ids = append(ids, id)
		}
		return ids
	case instructorinfo.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.removedcourseclasses))
		for id := range m.removedcourseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InstructorInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtitle {
		edges = append(edges, instructorinfo.EdgeTitle)
	}
	if m.clearedinstructorroom {
		edges = append(edges, instructorinfo.EdgeInstructorroom)
	}
	if m.cleareddepartment {
		edges = append(edges, instructorinfo.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InstructorInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case instructorinfo.EdgeTitle:
		return m.clearedtitle
	case instructorinfo.EdgeInstructorroom:
		return m.clearedinstructorroom
	case instructorinfo.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InstructorInfoMutation) ClearEdge(name string) error {
	switch name {
	case instructorinfo.EdgeTitle:
		m.ClearTitle()
		return nil
	case instructorinfo.EdgeInstructorroom:
		m.ClearInstructorroom()
		return nil
	case instructorinfo.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InstructorInfoMutation) ResetEdge(name string) error {
	switch name {
	case instructorinfo.EdgeTitle:
		m.ResetTitle()
		return nil
	case instructorinfo.EdgeInstructorroom:
		m.ResetInstructorroom()
		return nil
	case instructorinfo.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case instructorinfo.EdgeInstructor:
		m.ResetInstructor()
		return nil
	case instructorinfo.EdgeCourseclasses:
		m.ResetCourseclasses()
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo edge %s", name)
}

// InstructorRoomMutation represents an operation that mutate the InstructorRooms
// nodes in the graph.
type InstructorRoomMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_ROOM                  *string
	_BUILDING              *string
	clearedFields          map[string]struct{}
	instructorinfos        map[int]struct{}
	removedinstructorinfos map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*InstructorRoom, error)
}

var _ ent.Mutation = (*InstructorRoomMutation)(nil)

// instructorroomOption allows to manage the mutation configuration using functional options.
type instructorroomOption func(*InstructorRoomMutation)

// newInstructorRoomMutation creates new mutation for $n.Name.
func newInstructorRoomMutation(c config, op Op, opts ...instructorroomOption) *InstructorRoomMutation {
	m := &InstructorRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeInstructorRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstructorRoomID sets the id field of the mutation.
func withInstructorRoomID(id int) instructorroomOption {
	return func(m *InstructorRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *InstructorRoom
		)
		m.oldValue = func(ctx context.Context) (*InstructorRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstructorRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstructorRoom sets the old InstructorRoom of the mutation.
func withInstructorRoom(node *InstructorRoom) instructorroomOption {
	return func(m *InstructorRoomMutation) {
		m.oldValue = func(context.Context) (*InstructorRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstructorRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstructorRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InstructorRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetROOM sets the ROOM field.
func (m *InstructorRoomMutation) SetROOM(s string) {
	m._ROOM = &s
}

// ROOM returns the ROOM value in the mutation.
func (m *InstructorRoomMutation) ROOM() (r string, exists bool) {
	v := m._ROOM
	if v == nil {
		return
	}
	return *v, true
}

// OldROOM returns the old ROOM value of the InstructorRoom.
// If the InstructorRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorRoomMutation) OldROOM(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldROOM is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldROOM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldROOM: %w", err)
	}
	return oldValue.ROOM, nil
}

// ResetROOM reset all changes of the "ROOM" field.
func (m *InstructorRoomMutation) ResetROOM() {
	m._ROOM = nil
}

// SetBUILDING sets the BUILDING field.
func (m *InstructorRoomMutation) SetBUILDING(s string) {
	m._BUILDING = &s
}

// BUILDING returns the BUILDING value in the mutation.
func (m *InstructorRoomMutation) BUILDING() (r string, exists bool) {
	v := m._BUILDING
	if v == nil {
		return
	}
	return *v, true
}

// OldBUILDING returns the old BUILDING value of the InstructorRoom.
// If the InstructorRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorRoomMutation) OldBUILDING(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBUILDING is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBUILDING requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBUILDING: %w", err)
	}
	return oldValue.BUILDING, nil
}

// ResetBUILDING reset all changes of the "BUILDING" field.
func (m *InstructorRoomMutation) ResetBUILDING() {
	m._BUILDING = nil
}

// AddInstructorinfoIDs adds the instructorinfos edge to InstructorInfo by ids.
func (m *InstructorRoomMutation) AddInstructorinfoIDs(ids ...int) {
	if m.instructorinfos == nil {
		m.instructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.instructorinfos[ids[i]] = struct{}{}
	}
}

// RemoveInstructorinfoIDs removes the instructorinfos edge to InstructorInfo by ids.
func (m *InstructorRoomMutation) RemoveInstructorinfoIDs(ids ...int) {
	if m.removedinstructorinfos == nil {
		m.removedinstructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstructorinfos[ids[i]] = struct{}{}
	}
}

// RemovedInstructorinfos returns the removed ids of instructorinfos.
func (m *InstructorRoomMutation) RemovedInstructorinfosIDs() (ids []int) {
	for id := range m.removedinstructorinfos {
		ids = append(ids, id)
	}
	return
}

// InstructorinfosIDs returns the instructorinfos ids in the mutation.
func (m *InstructorRoomMutation) InstructorinfosIDs() (ids []int) {
	for id := range m.instructorinfos {
		ids = append(ids, id)
	}
	return
}

// ResetInstructorinfos reset all changes of the "instructorinfos" edge.
func (m *InstructorRoomMutation) ResetInstructorinfos() {
	m.instructorinfos = nil
	m.removedinstructorinfos = nil
}

// Op returns the operation name.
func (m *InstructorRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InstructorRoom).
func (m *InstructorRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InstructorRoomMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._ROOM != nil {
		fields = append(fields, instructorroom.FieldROOM)
	}
	if m._BUILDING != nil {
		fields = append(fields, instructorroom.FieldBUILDING)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InstructorRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instructorroom.FieldROOM:
		return m.ROOM()
	case instructorroom.FieldBUILDING:
		return m.BUILDING()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InstructorRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instructorroom.FieldROOM:
		return m.OldROOM(ctx)
	case instructorroom.FieldBUILDING:
		return m.OldBUILDING(ctx)
	}
	return nil, fmt.Errorf("unknown InstructorRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstructorRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instructorroom.FieldROOM:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetROOM(v)
		return nil
	case instructorroom.FieldBUILDING:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBUILDING(v)
		return nil
	}
	return fmt.Errorf("unknown InstructorRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InstructorRoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InstructorRoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstructorRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InstructorRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InstructorRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InstructorRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstructorRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InstructorRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InstructorRoomMutation) ResetField(name string) error {
	switch name {
	case instructorroom.FieldROOM:
		m.ResetROOM()
		return nil
	case instructorroom.FieldBUILDING:
		m.ResetBUILDING()
		return nil
	}
	return fmt.Errorf("unknown InstructorRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InstructorRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instructorinfos != nil {
		edges = append(edges, instructorroom.EdgeInstructorinfos)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InstructorRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instructorroom.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.instructorinfos))
		for id := range m.instructorinfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InstructorRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinstructorinfos != nil {
		edges = append(edges, instructorroom.EdgeInstructorinfos)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InstructorRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instructorroom.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.removedinstructorinfos))
		for id := range m.removedinstructorinfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InstructorRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InstructorRoomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InstructorRoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InstructorRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InstructorRoomMutation) ResetEdge(name string) error {
	switch name {
	case instructorroom.EdgeInstructorinfos:
		m.ResetInstructorinfos()
		return nil
	}
	return fmt.Errorf("unknown InstructorRoom edge %s", name)
}

// SubjectMutation represents an operation that mutate the Subjects
// nodes in the graph.
type SubjectMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_Subject_name           *string
	clearedFields           map[string]struct{}
	subject                 map[int]struct{}
	removedsubject          map[int]struct{}
	_SubjectsOffered        map[int]struct{}
	removed_SubjectsOffered map[int]struct{}
	courseclasses           map[int]struct{}
	removedcourseclasses    map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Subject, error)
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows to manage the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for $n.Name.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the id field of the mutation.
func withSubjectID(id int) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SubjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSubjectName sets the Subject_name field.
func (m *SubjectMutation) SetSubjectName(s string) {
	m._Subject_name = &s
}

// SubjectName returns the Subject_name value in the mutation.
func (m *SubjectMutation) SubjectName() (r string, exists bool) {
	v := m._Subject_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectName returns the old Subject_name value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldSubjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjectName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectName: %w", err)
	}
	return oldValue.SubjectName, nil
}

// ResetSubjectName reset all changes of the "Subject_name" field.
func (m *SubjectMutation) ResetSubjectName() {
	m._Subject_name = nil
}

// AddSubjectIDs adds the subject edge to Course by ids.
func (m *SubjectMutation) AddSubjectIDs(ids ...int) {
	if m.subject == nil {
		m.subject = make(map[int]struct{})
	}
	for i := range ids {
		m.subject[ids[i]] = struct{}{}
	}
}

// RemoveSubjectIDs removes the subject edge to Course by ids.
func (m *SubjectMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubject == nil {
		m.removedsubject = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsubject[ids[i]] = struct{}{}
	}
}

// RemovedSubject returns the removed ids of subject.
func (m *SubjectMutation) RemovedSubjectIDs() (ids []int) {
	for id := range m.removedsubject {
		ids = append(ids, id)
	}
	return
}

// SubjectIDs returns the subject ids in the mutation.
func (m *SubjectMutation) SubjectIDs() (ids []int) {
	for id := range m.subject {
		ids = append(ids, id)
	}
	return
}

// ResetSubject reset all changes of the "subject" edge.
func (m *SubjectMutation) ResetSubject() {
	m.subject = nil
	m.removedsubject = nil
}

// AddSubjectsOfferedIDs adds the SubjectsOffered edge to SubjectsOffered by ids.
func (m *SubjectMutation) AddSubjectsOfferedIDs(ids ...int) {
	if m._SubjectsOffered == nil {
		m._SubjectsOffered = make(map[int]struct{})
	}
	for i := range ids {
		m._SubjectsOffered[ids[i]] = struct{}{}
	}
}

// RemoveSubjectsOfferedIDs removes the SubjectsOffered edge to SubjectsOffered by ids.
func (m *SubjectMutation) RemoveSubjectsOfferedIDs(ids ...int) {
	if m.removed_SubjectsOffered == nil {
		m.removed_SubjectsOffered = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_SubjectsOffered[ids[i]] = struct{}{}
	}
}

// RemovedSubjectsOffered returns the removed ids of SubjectsOffered.
func (m *SubjectMutation) RemovedSubjectsOfferedIDs() (ids []int) {
	for id := range m.removed_SubjectsOffered {
		ids = append(ids, id)
	}
	return
}

// SubjectsOfferedIDs returns the SubjectsOffered ids in the mutation.
func (m *SubjectMutation) SubjectsOfferedIDs() (ids []int) {
	for id := range m._SubjectsOffered {
		ids = append(ids, id)
	}
	return
}

// ResetSubjectsOffered reset all changes of the "SubjectsOffered" edge.
func (m *SubjectMutation) ResetSubjectsOffered() {
	m._SubjectsOffered = nil
	m.removed_SubjectsOffered = nil
}

// AddCourseclassIDs adds the courseclasses edge to Courseclass by ids.
func (m *SubjectMutation) AddCourseclassIDs(ids ...int) {
	if m.courseclasses == nil {
		m.courseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.courseclasses[ids[i]] = struct{}{}
	}
}

// RemoveCourseclassIDs removes the courseclasses edge to Courseclass by ids.
func (m *SubjectMutation) RemoveCourseclassIDs(ids ...int) {
	if m.removedcourseclasses == nil {
		m.removedcourseclasses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcourseclasses[ids[i]] = struct{}{}
	}
}

// RemovedCourseclasses returns the removed ids of courseclasses.
func (m *SubjectMutation) RemovedCourseclassesIDs() (ids []int) {
	for id := range m.removedcourseclasses {
		ids = append(ids, id)
	}
	return
}

// CourseclassesIDs returns the courseclasses ids in the mutation.
func (m *SubjectMutation) CourseclassesIDs() (ids []int) {
	for id := range m.courseclasses {
		ids = append(ids, id)
	}
	return
}

// ResetCourseclasses reset all changes of the "courseclasses" edge.
func (m *SubjectMutation) ResetCourseclasses() {
	m.courseclasses = nil
	m.removedcourseclasses = nil
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Subject_name != nil {
		fields = append(fields, subject.FieldSubjectName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldSubjectName:
		return m.SubjectName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldSubjectName:
		return m.OldSubjectName(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldSubjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectName(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SubjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldSubjectName:
		m.ResetSubjectName()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.subject != nil {
		edges = append(edges, subject.EdgeSubject)
	}
	if m._SubjectsOffered != nil {
		edges = append(edges, subject.EdgeSubjectsOffered)
	}
	if m.courseclasses != nil {
		edges = append(edges, subject.EdgeCourseclasses)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeSubject:
		ids := make([]ent.Value, 0, len(m.subject))
		for id := range m.subject {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeSubjectsOffered:
		ids := make([]ent.Value, 0, len(m._SubjectsOffered))
		for id := range m._SubjectsOffered {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.courseclasses))
		for id := range m.courseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsubject != nil {
		edges = append(edges, subject.EdgeSubject)
	}
	if m.removed_SubjectsOffered != nil {
		edges = append(edges, subject.EdgeSubjectsOffered)
	}
	if m.removedcourseclasses != nil {
		edges = append(edges, subject.EdgeCourseclasses)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeSubject:
		ids := make([]ent.Value, 0, len(m.removedsubject))
		for id := range m.removedsubject {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeSubjectsOffered:
		ids := make([]ent.Value, 0, len(m.removed_SubjectsOffered))
		for id := range m.removed_SubjectsOffered {
			ids = append(ids, id)
		}
		return ids
	case subject.EdgeCourseclasses:
		ids := make([]ent.Value, 0, len(m.removedcourseclasses))
		for id := range m.removedcourseclasses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeSubject:
		m.ResetSubject()
		return nil
	case subject.EdgeSubjectsOffered:
		m.ResetSubjectsOffered()
		return nil
	case subject.EdgeCourseclasses:
		m.ResetCourseclasses()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// SubjectsOfferedMutation represents an operation that mutate the SubjectsOffereds
// nodes in the graph.
type SubjectsOfferedMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_AMOUNT         *string
	_STATUS         *string
	clearedFields   map[string]struct{}
	_Subject        *int
	cleared_Subject bool
	_Degree         *int
	cleared_Degree  bool
	_Year           *int
	cleared_Year    bool
	_Term           *int
	cleared_Term    bool
	done            bool
	oldValue        func(context.Context) (*SubjectsOffered, error)
}

var _ ent.Mutation = (*SubjectsOfferedMutation)(nil)

// subjectsofferedOption allows to manage the mutation configuration using functional options.
type subjectsofferedOption func(*SubjectsOfferedMutation)

// newSubjectsOfferedMutation creates new mutation for $n.Name.
func newSubjectsOfferedMutation(c config, op Op, opts ...subjectsofferedOption) *SubjectsOfferedMutation {
	m := &SubjectsOfferedMutation{
		config:        c,
		op:            op,
		typ:           TypeSubjectsOffered,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectsOfferedID sets the id field of the mutation.
func withSubjectsOfferedID(id int) subjectsofferedOption {
	return func(m *SubjectsOfferedMutation) {
		var (
			err   error
			once  sync.Once
			value *SubjectsOffered
		)
		m.oldValue = func(ctx context.Context) (*SubjectsOffered, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubjectsOffered.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubjectsOffered sets the old SubjectsOffered of the mutation.
func withSubjectsOffered(node *SubjectsOffered) subjectsofferedOption {
	return func(m *SubjectsOfferedMutation) {
		m.oldValue = func(context.Context) (*SubjectsOffered, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectsOfferedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectsOfferedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SubjectsOfferedMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAMOUNT sets the AMOUNT field.
func (m *SubjectsOfferedMutation) SetAMOUNT(s string) {
	m._AMOUNT = &s
}

// AMOUNT returns the AMOUNT value in the mutation.
func (m *SubjectsOfferedMutation) AMOUNT() (r string, exists bool) {
	v := m._AMOUNT
	if v == nil {
		return
	}
	return *v, true
}

// OldAMOUNT returns the old AMOUNT value of the SubjectsOffered.
// If the SubjectsOffered object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectsOfferedMutation) OldAMOUNT(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAMOUNT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAMOUNT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAMOUNT: %w", err)
	}
	return oldValue.AMOUNT, nil
}

// ResetAMOUNT reset all changes of the "AMOUNT" field.
func (m *SubjectsOfferedMutation) ResetAMOUNT() {
	m._AMOUNT = nil
}

// SetSTATUS sets the STATUS field.
func (m *SubjectsOfferedMutation) SetSTATUS(s string) {
	m._STATUS = &s
}

// STATUS returns the STATUS value in the mutation.
func (m *SubjectsOfferedMutation) STATUS() (r string, exists bool) {
	v := m._STATUS
	if v == nil {
		return
	}
	return *v, true
}

// OldSTATUS returns the old STATUS value of the SubjectsOffered.
// If the SubjectsOffered object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectsOfferedMutation) OldSTATUS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSTATUS is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSTATUS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSTATUS: %w", err)
	}
	return oldValue.STATUS, nil
}

// ResetSTATUS reset all changes of the "STATUS" field.
func (m *SubjectsOfferedMutation) ResetSTATUS() {
	m._STATUS = nil
}

// SetSubjectID sets the Subject edge to Subject by id.
func (m *SubjectsOfferedMutation) SetSubjectID(id int) {
	m._Subject = &id
}

// ClearSubject clears the Subject edge to Subject.
func (m *SubjectsOfferedMutation) ClearSubject() {
	m.cleared_Subject = true
}

// SubjectCleared returns if the edge Subject was cleared.
func (m *SubjectsOfferedMutation) SubjectCleared() bool {
	return m.cleared_Subject
}

// SubjectID returns the Subject id in the mutation.
func (m *SubjectsOfferedMutation) SubjectID() (id int, exists bool) {
	if m._Subject != nil {
		return *m._Subject, true
	}
	return
}

// SubjectIDs returns the Subject ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *SubjectsOfferedMutation) SubjectIDs() (ids []int) {
	if id := m._Subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject reset all changes of the "Subject" edge.
func (m *SubjectsOfferedMutation) ResetSubject() {
	m._Subject = nil
	m.cleared_Subject = false
}

// SetDegreeID sets the Degree edge to Degree by id.
func (m *SubjectsOfferedMutation) SetDegreeID(id int) {
	m._Degree = &id
}

// ClearDegree clears the Degree edge to Degree.
func (m *SubjectsOfferedMutation) ClearDegree() {
	m.cleared_Degree = true
}

// DegreeCleared returns if the edge Degree was cleared.
func (m *SubjectsOfferedMutation) DegreeCleared() bool {
	return m.cleared_Degree
}

// DegreeID returns the Degree id in the mutation.
func (m *SubjectsOfferedMutation) DegreeID() (id int, exists bool) {
	if m._Degree != nil {
		return *m._Degree, true
	}
	return
}

// DegreeIDs returns the Degree ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DegreeID instead. It exists only for internal usage by the builders.
func (m *SubjectsOfferedMutation) DegreeIDs() (ids []int) {
	if id := m._Degree; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDegree reset all changes of the "Degree" edge.
func (m *SubjectsOfferedMutation) ResetDegree() {
	m._Degree = nil
	m.cleared_Degree = false
}

// SetYearID sets the Year edge to Year by id.
func (m *SubjectsOfferedMutation) SetYearID(id int) {
	m._Year = &id
}

// ClearYear clears the Year edge to Year.
func (m *SubjectsOfferedMutation) ClearYear() {
	m.cleared_Year = true
}

// YearCleared returns if the edge Year was cleared.
func (m *SubjectsOfferedMutation) YearCleared() bool {
	return m.cleared_Year
}

// YearID returns the Year id in the mutation.
func (m *SubjectsOfferedMutation) YearID() (id int, exists bool) {
	if m._Year != nil {
		return *m._Year, true
	}
	return
}

// YearIDs returns the Year ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// YearID instead. It exists only for internal usage by the builders.
func (m *SubjectsOfferedMutation) YearIDs() (ids []int) {
	if id := m._Year; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetYear reset all changes of the "Year" edge.
func (m *SubjectsOfferedMutation) ResetYear() {
	m._Year = nil
	m.cleared_Year = false
}

// SetTermID sets the Term edge to Term by id.
func (m *SubjectsOfferedMutation) SetTermID(id int) {
	m._Term = &id
}

// ClearTerm clears the Term edge to Term.
func (m *SubjectsOfferedMutation) ClearTerm() {
	m.cleared_Term = true
}

// TermCleared returns if the edge Term was cleared.
func (m *SubjectsOfferedMutation) TermCleared() bool {
	return m.cleared_Term
}

// TermID returns the Term id in the mutation.
func (m *SubjectsOfferedMutation) TermID() (id int, exists bool) {
	if m._Term != nil {
		return *m._Term, true
	}
	return
}

// TermIDs returns the Term ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TermID instead. It exists only for internal usage by the builders.
func (m *SubjectsOfferedMutation) TermIDs() (ids []int) {
	if id := m._Term; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTerm reset all changes of the "Term" edge.
func (m *SubjectsOfferedMutation) ResetTerm() {
	m._Term = nil
	m.cleared_Term = false
}

// Op returns the operation name.
func (m *SubjectsOfferedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SubjectsOffered).
func (m *SubjectsOfferedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SubjectsOfferedMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._AMOUNT != nil {
		fields = append(fields, subjectsoffered.FieldAMOUNT)
	}
	if m._STATUS != nil {
		fields = append(fields, subjectsoffered.FieldSTATUS)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SubjectsOfferedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subjectsoffered.FieldAMOUNT:
		return m.AMOUNT()
	case subjectsoffered.FieldSTATUS:
		return m.STATUS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SubjectsOfferedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subjectsoffered.FieldAMOUNT:
		return m.OldAMOUNT(ctx)
	case subjectsoffered.FieldSTATUS:
		return m.OldSTATUS(ctx)
	}
	return nil, fmt.Errorf("unknown SubjectsOffered field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectsOfferedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subjectsoffered.FieldAMOUNT:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAMOUNT(v)
		return nil
	case subjectsoffered.FieldSTATUS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSTATUS(v)
		return nil
	}
	return fmt.Errorf("unknown SubjectsOffered field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SubjectsOfferedMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SubjectsOfferedMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectsOfferedMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubjectsOffered numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SubjectsOfferedMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SubjectsOfferedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectsOfferedMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubjectsOffered nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SubjectsOfferedMutation) ResetField(name string) error {
	switch name {
	case subjectsoffered.FieldAMOUNT:
		m.ResetAMOUNT()
		return nil
	case subjectsoffered.FieldSTATUS:
		m.ResetSTATUS()
		return nil
	}
	return fmt.Errorf("unknown SubjectsOffered field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SubjectsOfferedMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Subject != nil {
		edges = append(edges, subjectsoffered.EdgeSubject)
	}
	if m._Degree != nil {
		edges = append(edges, subjectsoffered.EdgeDegree)
	}
	if m._Year != nil {
		edges = append(edges, subjectsoffered.EdgeYear)
	}
	if m._Term != nil {
		edges = append(edges, subjectsoffered.EdgeTerm)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SubjectsOfferedMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subjectsoffered.EdgeSubject:
		if id := m._Subject; id != nil {
			return []ent.Value{*id}
		}
	case subjectsoffered.EdgeDegree:
		if id := m._Degree; id != nil {
			return []ent.Value{*id}
		}
	case subjectsoffered.EdgeYear:
		if id := m._Year; id != nil {
			return []ent.Value{*id}
		}
	case subjectsoffered.EdgeTerm:
		if id := m._Term; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SubjectsOfferedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SubjectsOfferedMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SubjectsOfferedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Subject {
		edges = append(edges, subjectsoffered.EdgeSubject)
	}
	if m.cleared_Degree {
		edges = append(edges, subjectsoffered.EdgeDegree)
	}
	if m.cleared_Year {
		edges = append(edges, subjectsoffered.EdgeYear)
	}
	if m.cleared_Term {
		edges = append(edges, subjectsoffered.EdgeTerm)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SubjectsOfferedMutation) EdgeCleared(name string) bool {
	switch name {
	case subjectsoffered.EdgeSubject:
		return m.cleared_Subject
	case subjectsoffered.EdgeDegree:
		return m.cleared_Degree
	case subjectsoffered.EdgeYear:
		return m.cleared_Year
	case subjectsoffered.EdgeTerm:
		return m.cleared_Term
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SubjectsOfferedMutation) ClearEdge(name string) error {
	switch name {
	case subjectsoffered.EdgeSubject:
		m.ClearSubject()
		return nil
	case subjectsoffered.EdgeDegree:
		m.ClearDegree()
		return nil
	case subjectsoffered.EdgeYear:
		m.ClearYear()
		return nil
	case subjectsoffered.EdgeTerm:
		m.ClearTerm()
		return nil
	}
	return fmt.Errorf("unknown SubjectsOffered unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SubjectsOfferedMutation) ResetEdge(name string) error {
	switch name {
	case subjectsoffered.EdgeSubject:
		m.ResetSubject()
		return nil
	case subjectsoffered.EdgeDegree:
		m.ResetDegree()
		return nil
	case subjectsoffered.EdgeYear:
		m.ResetYear()
		return nil
	case subjectsoffered.EdgeTerm:
		m.ResetTerm()
		return nil
	}
	return fmt.Errorf("unknown SubjectsOffered edge %s", name)
}

// TermMutation represents an operation that mutate the Terms
// nodes in the graph.
type TermMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_TERM                   *int
	add_TERM                *int
	clearedFields           map[string]struct{}
	_SubjectsOffered        map[int]struct{}
	removed_SubjectsOffered map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Term, error)
}

var _ ent.Mutation = (*TermMutation)(nil)

// termOption allows to manage the mutation configuration using functional options.
type termOption func(*TermMutation)

// newTermMutation creates new mutation for $n.Name.
func newTermMutation(c config, op Op, opts ...termOption) *TermMutation {
	m := &TermMutation{
		config:        c,
		op:            op,
		typ:           TypeTerm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTermID sets the id field of the mutation.
func withTermID(id int) termOption {
	return func(m *TermMutation) {
		var (
			err   error
			once  sync.Once
			value *Term
		)
		m.oldValue = func(ctx context.Context) (*Term, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Term.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTerm sets the old Term of the mutation.
func withTerm(node *Term) termOption {
	return func(m *TermMutation) {
		m.oldValue = func(context.Context) (*Term, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TermMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TermMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TermMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTERM sets the TERM field.
func (m *TermMutation) SetTERM(i int) {
	m._TERM = &i
	m.add_TERM = nil
}

// TERM returns the TERM value in the mutation.
func (m *TermMutation) TERM() (r int, exists bool) {
	v := m._TERM
	if v == nil {
		return
	}
	return *v, true
}

// OldTERM returns the old TERM value of the Term.
// If the Term object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TermMutation) OldTERM(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTERM is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTERM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTERM: %w", err)
	}
	return oldValue.TERM, nil
}

// AddTERM adds i to TERM.
func (m *TermMutation) AddTERM(i int) {
	if m.add_TERM != nil {
		*m.add_TERM += i
	} else {
		m.add_TERM = &i
	}
}

// AddedTERM returns the value that was added to the TERM field in this mutation.
func (m *TermMutation) AddedTERM() (r int, exists bool) {
	v := m.add_TERM
	if v == nil {
		return
	}
	return *v, true
}

// ResetTERM reset all changes of the "TERM" field.
func (m *TermMutation) ResetTERM() {
	m._TERM = nil
	m.add_TERM = nil
}

// AddSubjectsOfferedIDs adds the SubjectsOffered edge to SubjectsOffered by ids.
func (m *TermMutation) AddSubjectsOfferedIDs(ids ...int) {
	if m._SubjectsOffered == nil {
		m._SubjectsOffered = make(map[int]struct{})
	}
	for i := range ids {
		m._SubjectsOffered[ids[i]] = struct{}{}
	}
}

// RemoveSubjectsOfferedIDs removes the SubjectsOffered edge to SubjectsOffered by ids.
func (m *TermMutation) RemoveSubjectsOfferedIDs(ids ...int) {
	if m.removed_SubjectsOffered == nil {
		m.removed_SubjectsOffered = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_SubjectsOffered[ids[i]] = struct{}{}
	}
}

// RemovedSubjectsOffered returns the removed ids of SubjectsOffered.
func (m *TermMutation) RemovedSubjectsOfferedIDs() (ids []int) {
	for id := range m.removed_SubjectsOffered {
		ids = append(ids, id)
	}
	return
}

// SubjectsOfferedIDs returns the SubjectsOffered ids in the mutation.
func (m *TermMutation) SubjectsOfferedIDs() (ids []int) {
	for id := range m._SubjectsOffered {
		ids = append(ids, id)
	}
	return
}

// ResetSubjectsOffered reset all changes of the "SubjectsOffered" edge.
func (m *TermMutation) ResetSubjectsOffered() {
	m._SubjectsOffered = nil
	m.removed_SubjectsOffered = nil
}

// Op returns the operation name.
func (m *TermMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Term).
func (m *TermMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TermMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TERM != nil {
		fields = append(fields, term.FieldTERM)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TermMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case term.FieldTERM:
		return m.TERM()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TermMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case term.FieldTERM:
		return m.OldTERM(ctx)
	}
	return nil, fmt.Errorf("unknown Term field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TermMutation) SetField(name string, value ent.Value) error {
	switch name {
	case term.FieldTERM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTERM(v)
		return nil
	}
	return fmt.Errorf("unknown Term field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TermMutation) AddedFields() []string {
	var fields []string
	if m.add_TERM != nil {
		fields = append(fields, term.FieldTERM)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TermMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case term.FieldTERM:
		return m.AddedTERM()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TermMutation) AddField(name string, value ent.Value) error {
	switch name {
	case term.FieldTERM:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTERM(v)
		return nil
	}
	return fmt.Errorf("unknown Term numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TermMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TermMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TermMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Term nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TermMutation) ResetField(name string) error {
	switch name {
	case term.FieldTERM:
		m.ResetTERM()
		return nil
	}
	return fmt.Errorf("unknown Term field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TermMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._SubjectsOffered != nil {
		edges = append(edges, term.EdgeSubjectsOffered)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TermMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case term.EdgeSubjectsOffered:
		ids := make([]ent.Value, 0, len(m._SubjectsOffered))
		for id := range m._SubjectsOffered {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TermMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_SubjectsOffered != nil {
		edges = append(edges, term.EdgeSubjectsOffered)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TermMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case term.EdgeSubjectsOffered:
		ids := make([]ent.Value, 0, len(m.removed_SubjectsOffered))
		for id := range m.removed_SubjectsOffered {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TermMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TermMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TermMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Term unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TermMutation) ResetEdge(name string) error {
	switch name {
	case term.EdgeSubjectsOffered:
		m.ResetSubjectsOffered()
		return nil
	}
	return fmt.Errorf("unknown Term edge %s", name)
}

// TitleMutation represents an operation that mutate the Titles
// nodes in the graph.
type TitleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_TITLE                 *string
	clearedFields          map[string]struct{}
	instructorinfos        map[int]struct{}
	removedinstructorinfos map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Title, error)
}

var _ ent.Mutation = (*TitleMutation)(nil)

// titleOption allows to manage the mutation configuration using functional options.
type titleOption func(*TitleMutation)

// newTitleMutation creates new mutation for $n.Name.
func newTitleMutation(c config, op Op, opts ...titleOption) *TitleMutation {
	m := &TitleMutation{
		config:        c,
		op:            op,
		typ:           TypeTitle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTitleID sets the id field of the mutation.
func withTitleID(id int) titleOption {
	return func(m *TitleMutation) {
		var (
			err   error
			once  sync.Once
			value *Title
		)
		m.oldValue = func(ctx context.Context) (*Title, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Title.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTitle sets the old Title of the mutation.
func withTitle(node *Title) titleOption {
	return func(m *TitleMutation) {
		m.oldValue = func(context.Context) (*Title, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TitleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TitleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TitleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTITLE sets the TITLE field.
func (m *TitleMutation) SetTITLE(s string) {
	m._TITLE = &s
}

// TITLE returns the TITLE value in the mutation.
func (m *TitleMutation) TITLE() (r string, exists bool) {
	v := m._TITLE
	if v == nil {
		return
	}
	return *v, true
}

// OldTITLE returns the old TITLE value of the Title.
// If the Title object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TitleMutation) OldTITLE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTITLE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTITLE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTITLE: %w", err)
	}
	return oldValue.TITLE, nil
}

// ResetTITLE reset all changes of the "TITLE" field.
func (m *TitleMutation) ResetTITLE() {
	m._TITLE = nil
}

// AddInstructorinfoIDs adds the instructorinfos edge to InstructorInfo by ids.
func (m *TitleMutation) AddInstructorinfoIDs(ids ...int) {
	if m.instructorinfos == nil {
		m.instructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.instructorinfos[ids[i]] = struct{}{}
	}
}

// RemoveInstructorinfoIDs removes the instructorinfos edge to InstructorInfo by ids.
func (m *TitleMutation) RemoveInstructorinfoIDs(ids ...int) {
	if m.removedinstructorinfos == nil {
		m.removedinstructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstructorinfos[ids[i]] = struct{}{}
	}
}

// RemovedInstructorinfos returns the removed ids of instructorinfos.
func (m *TitleMutation) RemovedInstructorinfosIDs() (ids []int) {
	for id := range m.removedinstructorinfos {
		ids = append(ids, id)
	}
	return
}

// InstructorinfosIDs returns the instructorinfos ids in the mutation.
func (m *TitleMutation) InstructorinfosIDs() (ids []int) {
	for id := range m.instructorinfos {
		ids = append(ids, id)
	}
	return
}

// ResetInstructorinfos reset all changes of the "instructorinfos" edge.
func (m *TitleMutation) ResetInstructorinfos() {
	m.instructorinfos = nil
	m.removedinstructorinfos = nil
}

// Op returns the operation name.
func (m *TitleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Title).
func (m *TitleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TitleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TITLE != nil {
		fields = append(fields, title.FieldTITLE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TitleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case title.FieldTITLE:
		return m.TITLE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TitleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case title.FieldTITLE:
		return m.OldTITLE(ctx)
	}
	return nil, fmt.Errorf("unknown Title field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case title.FieldTITLE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTITLE(v)
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TitleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TitleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Title numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TitleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TitleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TitleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Title nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TitleMutation) ResetField(name string) error {
	switch name {
	case title.FieldTITLE:
		m.ResetTITLE()
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TitleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instructorinfos != nil {
		edges = append(edges, title.EdgeInstructorinfos)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TitleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.instructorinfos))
		for id := range m.instructorinfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TitleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinstructorinfos != nil {
		edges = append(edges, title.EdgeInstructorinfos)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TitleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.removedinstructorinfos))
		for id := range m.removedinstructorinfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TitleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TitleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TitleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Title unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TitleMutation) ResetEdge(name string) error {
	switch name {
	case title.EdgeInstructorinfos:
		m.ResetInstructorinfos()
		return nil
	}
	return fmt.Errorf("unknown Title edge %s", name)
}

// YearMutation represents an operation that mutate the Years
// nodes in the graph.
type YearMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_YEAR                   *int
	add_YEAR                *int
	clearedFields           map[string]struct{}
	_SubjectsOffered        map[int]struct{}
	removed_SubjectsOffered map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Year, error)
}

var _ ent.Mutation = (*YearMutation)(nil)

// yearOption allows to manage the mutation configuration using functional options.
type yearOption func(*YearMutation)

// newYearMutation creates new mutation for $n.Name.
func newYearMutation(c config, op Op, opts ...yearOption) *YearMutation {
	m := &YearMutation{
		config:        c,
		op:            op,
		typ:           TypeYear,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withYearID sets the id field of the mutation.
func withYearID(id int) yearOption {
	return func(m *YearMutation) {
		var (
			err   error
			once  sync.Once
			value *Year
		)
		m.oldValue = func(ctx context.Context) (*Year, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Year.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withYear sets the old Year of the mutation.
func withYear(node *Year) yearOption {
	return func(m *YearMutation) {
		m.oldValue = func(context.Context) (*Year, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m YearMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m YearMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *YearMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetYEAR sets the YEAR field.
func (m *YearMutation) SetYEAR(i int) {
	m._YEAR = &i
	m.add_YEAR = nil
}

// YEAR returns the YEAR value in the mutation.
func (m *YearMutation) YEAR() (r int, exists bool) {
	v := m._YEAR
	if v == nil {
		return
	}
	return *v, true
}

// OldYEAR returns the old YEAR value of the Year.
// If the Year object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *YearMutation) OldYEAR(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldYEAR is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldYEAR requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYEAR: %w", err)
	}
	return oldValue.YEAR, nil
}

// AddYEAR adds i to YEAR.
func (m *YearMutation) AddYEAR(i int) {
	if m.add_YEAR != nil {
		*m.add_YEAR += i
	} else {
		m.add_YEAR = &i
	}
}

// AddedYEAR returns the value that was added to the YEAR field in this mutation.
func (m *YearMutation) AddedYEAR() (r int, exists bool) {
	v := m.add_YEAR
	if v == nil {
		return
	}
	return *v, true
}

// ResetYEAR reset all changes of the "YEAR" field.
func (m *YearMutation) ResetYEAR() {
	m._YEAR = nil
	m.add_YEAR = nil
}

// AddSubjectsOfferedIDs adds the SubjectsOffered edge to SubjectsOffered by ids.
func (m *YearMutation) AddSubjectsOfferedIDs(ids ...int) {
	if m._SubjectsOffered == nil {
		m._SubjectsOffered = make(map[int]struct{})
	}
	for i := range ids {
		m._SubjectsOffered[ids[i]] = struct{}{}
	}
}

// RemoveSubjectsOfferedIDs removes the SubjectsOffered edge to SubjectsOffered by ids.
func (m *YearMutation) RemoveSubjectsOfferedIDs(ids ...int) {
	if m.removed_SubjectsOffered == nil {
		m.removed_SubjectsOffered = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_SubjectsOffered[ids[i]] = struct{}{}
	}
}

// RemovedSubjectsOffered returns the removed ids of SubjectsOffered.
func (m *YearMutation) RemovedSubjectsOfferedIDs() (ids []int) {
	for id := range m.removed_SubjectsOffered {
		ids = append(ids, id)
	}
	return
}

// SubjectsOfferedIDs returns the SubjectsOffered ids in the mutation.
func (m *YearMutation) SubjectsOfferedIDs() (ids []int) {
	for id := range m._SubjectsOffered {
		ids = append(ids, id)
	}
	return
}

// ResetSubjectsOffered reset all changes of the "SubjectsOffered" edge.
func (m *YearMutation) ResetSubjectsOffered() {
	m._SubjectsOffered = nil
	m.removed_SubjectsOffered = nil
}

// Op returns the operation name.
func (m *YearMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Year).
func (m *YearMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *YearMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._YEAR != nil {
		fields = append(fields, year.FieldYEAR)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *YearMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case year.FieldYEAR:
		return m.YEAR()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *YearMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case year.FieldYEAR:
		return m.OldYEAR(ctx)
	}
	return nil, fmt.Errorf("unknown Year field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *YearMutation) SetField(name string, value ent.Value) error {
	switch name {
	case year.FieldYEAR:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYEAR(v)
		return nil
	}
	return fmt.Errorf("unknown Year field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *YearMutation) AddedFields() []string {
	var fields []string
	if m.add_YEAR != nil {
		fields = append(fields, year.FieldYEAR)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *YearMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case year.FieldYEAR:
		return m.AddedYEAR()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *YearMutation) AddField(name string, value ent.Value) error {
	switch name {
	case year.FieldYEAR:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYEAR(v)
		return nil
	}
	return fmt.Errorf("unknown Year numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *YearMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *YearMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *YearMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Year nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *YearMutation) ResetField(name string) error {
	switch name {
	case year.FieldYEAR:
		m.ResetYEAR()
		return nil
	}
	return fmt.Errorf("unknown Year field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *YearMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._SubjectsOffered != nil {
		edges = append(edges, year.EdgeSubjectsOffered)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *YearMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case year.EdgeSubjectsOffered:
		ids := make([]ent.Value, 0, len(m._SubjectsOffered))
		for id := range m._SubjectsOffered {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *YearMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_SubjectsOffered != nil {
		edges = append(edges, year.EdgeSubjectsOffered)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *YearMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case year.EdgeSubjectsOffered:
		ids := make([]ent.Value, 0, len(m.removed_SubjectsOffered))
		for id := range m.removed_SubjectsOffered {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *YearMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *YearMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *YearMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Year unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *YearMutation) ResetEdge(name string) error {
	switch name {
	case year.EdgeSubjectsOffered:
		m.ResetSubjectsOffered()
		return nil
	}
	return fmt.Errorf("unknown Year edge %s", name)
}
