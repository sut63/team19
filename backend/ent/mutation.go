// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/team19/app/ent/course"
	"github.com/team19/app/ent/degree"
	"github.com/team19/app/ent/department"
	"github.com/team19/app/ent/instructorinfo"
	"github.com/team19/app/ent/instructorroom"
	"github.com/team19/app/ent/subject"
	"github.com/team19/app/ent/title"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCourse         = "Course"
	TypeDegree         = "Degree"
	TypeDepartment     = "Department"
	TypeInstructorInfo = "InstructorInfo"
	TypeInstructorRoom = "InstructorRoom"
	TypeSubject        = "Subject"
	TypeTitle          = "Title"
)

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Course_name              *string
	clearedFields             map[string]struct{}
	_InstructorInfo_id        *int
	cleared_InstructorInfo_id bool
	_Department_id            *int
	cleared_Department_id     bool
	_Degree_id                *int
	cleared_Degree_id         bool
	_Subject_id               *int
	cleared_Subject_id        bool
	done                      bool
	oldValue                  func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCourseName sets the Course_name field.
func (m *CourseMutation) SetCourseName(s string) {
	m._Course_name = &s
}

// CourseName returns the Course_name value in the mutation.
func (m *CourseMutation) CourseName() (r string, exists bool) {
	v := m._Course_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseName returns the old Course_name value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldCourseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseName: %w", err)
	}
	return oldValue.CourseName, nil
}

// ResetCourseName reset all changes of the "Course_name" field.
func (m *CourseMutation) ResetCourseName() {
	m._Course_name = nil
}

// SetInstructorInfoIDID sets the InstructorInfo_id edge to InstructorInfo by id.
func (m *CourseMutation) SetInstructorInfoIDID(id int) {
	m._InstructorInfo_id = &id
}

// ClearInstructorInfoID clears the InstructorInfo_id edge to InstructorInfo.
func (m *CourseMutation) ClearInstructorInfoID() {
	m.cleared_InstructorInfo_id = true
}

// InstructorInfoIDCleared returns if the edge InstructorInfo_id was cleared.
func (m *CourseMutation) InstructorInfoIDCleared() bool {
	return m.cleared_InstructorInfo_id
}

// InstructorInfoIDID returns the InstructorInfo_id id in the mutation.
func (m *CourseMutation) InstructorInfoIDID() (id int, exists bool) {
	if m._InstructorInfo_id != nil {
		return *m._InstructorInfo_id, true
	}
	return
}

// InstructorInfoIDIDs returns the InstructorInfo_id ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InstructorInfoIDID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) InstructorInfoIDIDs() (ids []int) {
	if id := m._InstructorInfo_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstructorInfoID reset all changes of the "InstructorInfo_id" edge.
func (m *CourseMutation) ResetInstructorInfoID() {
	m._InstructorInfo_id = nil
	m.cleared_InstructorInfo_id = false
}

// SetDepartmentIDID sets the Department_id edge to Department by id.
func (m *CourseMutation) SetDepartmentIDID(id int) {
	m._Department_id = &id
}

// ClearDepartmentID clears the Department_id edge to Department.
func (m *CourseMutation) ClearDepartmentID() {
	m.cleared_Department_id = true
}

// DepartmentIDCleared returns if the edge Department_id was cleared.
func (m *CourseMutation) DepartmentIDCleared() bool {
	return m.cleared_Department_id
}

// DepartmentIDID returns the Department_id id in the mutation.
func (m *CourseMutation) DepartmentIDID() (id int, exists bool) {
	if m._Department_id != nil {
		return *m._Department_id, true
	}
	return
}

// DepartmentIDIDs returns the Department_id ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentIDID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) DepartmentIDIDs() (ids []int) {
	if id := m._Department_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartmentID reset all changes of the "Department_id" edge.
func (m *CourseMutation) ResetDepartmentID() {
	m._Department_id = nil
	m.cleared_Department_id = false
}

// SetDegreeIDID sets the Degree_id edge to Degree by id.
func (m *CourseMutation) SetDegreeIDID(id int) {
	m._Degree_id = &id
}

// ClearDegreeID clears the Degree_id edge to Degree.
func (m *CourseMutation) ClearDegreeID() {
	m.cleared_Degree_id = true
}

// DegreeIDCleared returns if the edge Degree_id was cleared.
func (m *CourseMutation) DegreeIDCleared() bool {
	return m.cleared_Degree_id
}

// DegreeIDID returns the Degree_id id in the mutation.
func (m *CourseMutation) DegreeIDID() (id int, exists bool) {
	if m._Degree_id != nil {
		return *m._Degree_id, true
	}
	return
}

// DegreeIDIDs returns the Degree_id ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DegreeIDID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) DegreeIDIDs() (ids []int) {
	if id := m._Degree_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDegreeID reset all changes of the "Degree_id" edge.
func (m *CourseMutation) ResetDegreeID() {
	m._Degree_id = nil
	m.cleared_Degree_id = false
}

// SetSubjectIDID sets the Subject_id edge to Subject by id.
func (m *CourseMutation) SetSubjectIDID(id int) {
	m._Subject_id = &id
}

// ClearSubjectID clears the Subject_id edge to Subject.
func (m *CourseMutation) ClearSubjectID() {
	m.cleared_Subject_id = true
}

// SubjectIDCleared returns if the edge Subject_id was cleared.
func (m *CourseMutation) SubjectIDCleared() bool {
	return m.cleared_Subject_id
}

// SubjectIDID returns the Subject_id id in the mutation.
func (m *CourseMutation) SubjectIDID() (id int, exists bool) {
	if m._Subject_id != nil {
		return *m._Subject_id, true
	}
	return
}

// SubjectIDIDs returns the Subject_id ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SubjectIDID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) SubjectIDIDs() (ids []int) {
	if id := m._Subject_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubjectID reset all changes of the "Subject_id" edge.
func (m *CourseMutation) ResetSubjectID() {
	m._Subject_id = nil
	m.cleared_Subject_id = false
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Course_name != nil {
		fields = append(fields, course.FieldCourseName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldCourseName:
		return m.CourseName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldCourseName:
		return m.OldCourseName(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldCourseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseName(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldCourseName:
		m.ResetCourseName()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._InstructorInfo_id != nil {
		edges = append(edges, course.EdgeInstructorInfoID)
	}
	if m._Department_id != nil {
		edges = append(edges, course.EdgeDepartmentID)
	}
	if m._Degree_id != nil {
		edges = append(edges, course.EdgeDegreeID)
	}
	if m._Subject_id != nil {
		edges = append(edges, course.EdgeSubjectID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeInstructorInfoID:
		if id := m._InstructorInfo_id; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeDepartmentID:
		if id := m._Department_id; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeDegreeID:
		if id := m._Degree_id; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeSubjectID:
		if id := m._Subject_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_InstructorInfo_id {
		edges = append(edges, course.EdgeInstructorInfoID)
	}
	if m.cleared_Department_id {
		edges = append(edges, course.EdgeDepartmentID)
	}
	if m.cleared_Degree_id {
		edges = append(edges, course.EdgeDegreeID)
	}
	if m.cleared_Subject_id {
		edges = append(edges, course.EdgeSubjectID)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeInstructorInfoID:
		return m.cleared_InstructorInfo_id
	case course.EdgeDepartmentID:
		return m.cleared_Department_id
	case course.EdgeDegreeID:
		return m.cleared_Degree_id
	case course.EdgeSubjectID:
		return m.cleared_Subject_id
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeInstructorInfoID:
		m.ClearInstructorInfoID()
		return nil
	case course.EdgeDepartmentID:
		m.ClearDepartmentID()
		return nil
	case course.EdgeDegreeID:
		m.ClearDegreeID()
		return nil
	case course.EdgeSubjectID:
		m.ClearSubjectID()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeInstructorInfoID:
		m.ResetInstructorInfoID()
		return nil
	case course.EdgeDepartmentID:
		m.ResetDepartmentID()
		return nil
	case course.EdgeDegreeID:
		m.ResetDegreeID()
		return nil
	case course.EdgeSubjectID:
		m.ResetSubjectID()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// DegreeMutation represents an operation that mutate the Degrees
// nodes in the graph.
type DegreeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Degree_name  *string
	clearedFields map[string]struct{}
	degree        map[int]struct{}
	removeddegree map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Degree, error)
}

var _ ent.Mutation = (*DegreeMutation)(nil)

// degreeOption allows to manage the mutation configuration using functional options.
type degreeOption func(*DegreeMutation)

// newDegreeMutation creates new mutation for $n.Name.
func newDegreeMutation(c config, op Op, opts ...degreeOption) *DegreeMutation {
	m := &DegreeMutation{
		config:        c,
		op:            op,
		typ:           TypeDegree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDegreeID sets the id field of the mutation.
func withDegreeID(id int) degreeOption {
	return func(m *DegreeMutation) {
		var (
			err   error
			once  sync.Once
			value *Degree
		)
		m.oldValue = func(ctx context.Context) (*Degree, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Degree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDegree sets the old Degree of the mutation.
func withDegree(node *Degree) degreeOption {
	return func(m *DegreeMutation) {
		m.oldValue = func(context.Context) (*Degree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DegreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DegreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DegreeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDegreeName sets the Degree_name field.
func (m *DegreeMutation) SetDegreeName(s string) {
	m._Degree_name = &s
}

// DegreeName returns the Degree_name value in the mutation.
func (m *DegreeMutation) DegreeName() (r string, exists bool) {
	v := m._Degree_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDegreeName returns the old Degree_name value of the Degree.
// If the Degree object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DegreeMutation) OldDegreeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDegreeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDegreeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegreeName: %w", err)
	}
	return oldValue.DegreeName, nil
}

// ResetDegreeName reset all changes of the "Degree_name" field.
func (m *DegreeMutation) ResetDegreeName() {
	m._Degree_name = nil
}

// AddDegreeIDs adds the degree edge to Course by ids.
func (m *DegreeMutation) AddDegreeIDs(ids ...int) {
	if m.degree == nil {
		m.degree = make(map[int]struct{})
	}
	for i := range ids {
		m.degree[ids[i]] = struct{}{}
	}
}

// RemoveDegreeIDs removes the degree edge to Course by ids.
func (m *DegreeMutation) RemoveDegreeIDs(ids ...int) {
	if m.removeddegree == nil {
		m.removeddegree = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddegree[ids[i]] = struct{}{}
	}
}

// RemovedDegree returns the removed ids of degree.
func (m *DegreeMutation) RemovedDegreeIDs() (ids []int) {
	for id := range m.removeddegree {
		ids = append(ids, id)
	}
	return
}

// DegreeIDs returns the degree ids in the mutation.
func (m *DegreeMutation) DegreeIDs() (ids []int) {
	for id := range m.degree {
		ids = append(ids, id)
	}
	return
}

// ResetDegree reset all changes of the "degree" edge.
func (m *DegreeMutation) ResetDegree() {
	m.degree = nil
	m.removeddegree = nil
}

// Op returns the operation name.
func (m *DegreeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Degree).
func (m *DegreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DegreeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Degree_name != nil {
		fields = append(fields, degree.FieldDegreeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DegreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case degree.FieldDegreeName:
		return m.DegreeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DegreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case degree.FieldDegreeName:
		return m.OldDegreeName(ctx)
	}
	return nil, fmt.Errorf("unknown Degree field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DegreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case degree.FieldDegreeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegreeName(v)
		return nil
	}
	return fmt.Errorf("unknown Degree field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DegreeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DegreeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DegreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Degree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DegreeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DegreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DegreeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Degree nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DegreeMutation) ResetField(name string) error {
	switch name {
	case degree.FieldDegreeName:
		m.ResetDegreeName()
		return nil
	}
	return fmt.Errorf("unknown Degree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DegreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.degree != nil {
		edges = append(edges, degree.EdgeDegree)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DegreeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case degree.EdgeDegree:
		ids := make([]ent.Value, 0, len(m.degree))
		for id := range m.degree {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DegreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddegree != nil {
		edges = append(edges, degree.EdgeDegree)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DegreeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case degree.EdgeDegree:
		ids := make([]ent.Value, 0, len(m.removeddegree))
		for id := range m.removeddegree {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DegreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DegreeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DegreeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Degree unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DegreeMutation) ResetEdge(name string) error {
	switch name {
	case degree.EdgeDegree:
		m.ResetDegree()
		return nil
	}
	return fmt.Errorf("unknown Degree edge %s", name)
}

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_DEPARTMENT            *string
	_FACULTY               *string
	clearedFields          map[string]struct{}
	instructorinfos        map[int]struct{}
	removedinstructorinfos map[int]struct{}
	department             map[int]struct{}
	removeddepartment      map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDEPARTMENT sets the DEPARTMENT field.
func (m *DepartmentMutation) SetDEPARTMENT(s string) {
	m._DEPARTMENT = &s
}

// DEPARTMENT returns the DEPARTMENT value in the mutation.
func (m *DepartmentMutation) DEPARTMENT() (r string, exists bool) {
	v := m._DEPARTMENT
	if v == nil {
		return
	}
	return *v, true
}

// OldDEPARTMENT returns the old DEPARTMENT value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldDEPARTMENT(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDEPARTMENT is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDEPARTMENT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDEPARTMENT: %w", err)
	}
	return oldValue.DEPARTMENT, nil
}

// ResetDEPARTMENT reset all changes of the "DEPARTMENT" field.
func (m *DepartmentMutation) ResetDEPARTMENT() {
	m._DEPARTMENT = nil
}

// SetFACULTY sets the FACULTY field.
func (m *DepartmentMutation) SetFACULTY(s string) {
	m._FACULTY = &s
}

// FACULTY returns the FACULTY value in the mutation.
func (m *DepartmentMutation) FACULTY() (r string, exists bool) {
	v := m._FACULTY
	if v == nil {
		return
	}
	return *v, true
}

// OldFACULTY returns the old FACULTY value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldFACULTY(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFACULTY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFACULTY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFACULTY: %w", err)
	}
	return oldValue.FACULTY, nil
}

// ResetFACULTY reset all changes of the "FACULTY" field.
func (m *DepartmentMutation) ResetFACULTY() {
	m._FACULTY = nil
}

// AddInstructorinfoIDs adds the instructorinfos edge to InstructorInfo by ids.
func (m *DepartmentMutation) AddInstructorinfoIDs(ids ...int) {
	if m.instructorinfos == nil {
		m.instructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.instructorinfos[ids[i]] = struct{}{}
	}
}

// RemoveInstructorinfoIDs removes the instructorinfos edge to InstructorInfo by ids.
func (m *DepartmentMutation) RemoveInstructorinfoIDs(ids ...int) {
	if m.removedinstructorinfos == nil {
		m.removedinstructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstructorinfos[ids[i]] = struct{}{}
	}
}

// RemovedInstructorinfos returns the removed ids of instructorinfos.
func (m *DepartmentMutation) RemovedInstructorinfosIDs() (ids []int) {
	for id := range m.removedinstructorinfos {
		ids = append(ids, id)
	}
	return
}

// InstructorinfosIDs returns the instructorinfos ids in the mutation.
func (m *DepartmentMutation) InstructorinfosIDs() (ids []int) {
	for id := range m.instructorinfos {
		ids = append(ids, id)
	}
	return
}

// ResetInstructorinfos reset all changes of the "instructorinfos" edge.
func (m *DepartmentMutation) ResetInstructorinfos() {
	m.instructorinfos = nil
	m.removedinstructorinfos = nil
}

// AddDepartmentIDs adds the department edge to Course by ids.
func (m *DepartmentMutation) AddDepartmentIDs(ids ...int) {
	if m.department == nil {
		m.department = make(map[int]struct{})
	}
	for i := range ids {
		m.department[ids[i]] = struct{}{}
	}
}

// RemoveDepartmentIDs removes the department edge to Course by ids.
func (m *DepartmentMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartment == nil {
		m.removeddepartment = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartment[ids[i]] = struct{}{}
	}
}

// RemovedDepartment returns the removed ids of department.
func (m *DepartmentMutation) RemovedDepartmentIDs() (ids []int) {
	for id := range m.removeddepartment {
		ids = append(ids, id)
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
func (m *DepartmentMutation) DepartmentIDs() (ids []int) {
	for id := range m.department {
		ids = append(ids, id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *DepartmentMutation) ResetDepartment() {
	m.department = nil
	m.removeddepartment = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._DEPARTMENT != nil {
		fields = append(fields, department.FieldDEPARTMENT)
	}
	if m._FACULTY != nil {
		fields = append(fields, department.FieldFACULTY)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDEPARTMENT:
		return m.DEPARTMENT()
	case department.FieldFACULTY:
		return m.FACULTY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDEPARTMENT:
		return m.OldDEPARTMENT(ctx)
	case department.FieldFACULTY:
		return m.OldFACULTY(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDEPARTMENT:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDEPARTMENT(v)
		return nil
	case department.FieldFACULTY:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFACULTY(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDEPARTMENT:
		m.ResetDEPARTMENT()
		return nil
	case department.FieldFACULTY:
		m.ResetFACULTY()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.instructorinfos != nil {
		edges = append(edges, department.EdgeInstructorinfos)
	}
	if m.department != nil {
		edges = append(edges, department.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.instructorinfos))
		for id := range m.instructorinfos {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeDepartment:
		ids := make([]ent.Value, 0, len(m.department))
		for id := range m.department {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinstructorinfos != nil {
		edges = append(edges, department.EdgeInstructorinfos)
	}
	if m.removeddepartment != nil {
		edges = append(edges, department.EdgeDepartment)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.removedinstructorinfos))
		for id := range m.removedinstructorinfos {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeDepartment:
		ids := make([]ent.Value, 0, len(m.removeddepartment))
		for id := range m.removeddepartment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeInstructorinfos:
		m.ResetInstructorinfos()
		return nil
	case department.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// InstructorInfoMutation represents an operation that mutate the InstructorInfos
// nodes in the graph.
type InstructorInfoMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	_NAME                 *string
	_PHONENUMBER          *int
	add_PHONENUMBER       *int
	_EMAIL                *string
	_PASSWORD             *string
	clearedFields         map[string]struct{}
	title                 *int
	clearedtitle          bool
	instructorroom        *int
	clearedinstructorroom bool
	department            *int
	cleareddepartment     bool
	instructor            map[int]struct{}
	removedinstructor     map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*InstructorInfo, error)
}

var _ ent.Mutation = (*InstructorInfoMutation)(nil)

// instructorinfoOption allows to manage the mutation configuration using functional options.
type instructorinfoOption func(*InstructorInfoMutation)

// newInstructorInfoMutation creates new mutation for $n.Name.
func newInstructorInfoMutation(c config, op Op, opts ...instructorinfoOption) *InstructorInfoMutation {
	m := &InstructorInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeInstructorInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstructorInfoID sets the id field of the mutation.
func withInstructorInfoID(id int) instructorinfoOption {
	return func(m *InstructorInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *InstructorInfo
		)
		m.oldValue = func(ctx context.Context) (*InstructorInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstructorInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstructorInfo sets the old InstructorInfo of the mutation.
func withInstructorInfo(node *InstructorInfo) instructorinfoOption {
	return func(m *InstructorInfoMutation) {
		m.oldValue = func(context.Context) (*InstructorInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstructorInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstructorInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InstructorInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNAME sets the NAME field.
func (m *InstructorInfoMutation) SetNAME(s string) {
	m._NAME = &s
}

// NAME returns the NAME value in the mutation.
func (m *InstructorInfoMutation) NAME() (r string, exists bool) {
	v := m._NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldNAME returns the old NAME value of the InstructorInfo.
// If the InstructorInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorInfoMutation) OldNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNAME: %w", err)
	}
	return oldValue.NAME, nil
}

// ResetNAME reset all changes of the "NAME" field.
func (m *InstructorInfoMutation) ResetNAME() {
	m._NAME = nil
}

// SetPHONENUMBER sets the PHONENUMBER field.
func (m *InstructorInfoMutation) SetPHONENUMBER(i int) {
	m._PHONENUMBER = &i
	m.add_PHONENUMBER = nil
}

// PHONENUMBER returns the PHONENUMBER value in the mutation.
func (m *InstructorInfoMutation) PHONENUMBER() (r int, exists bool) {
	v := m._PHONENUMBER
	if v == nil {
		return
	}
	return *v, true
}

// OldPHONENUMBER returns the old PHONENUMBER value of the InstructorInfo.
// If the InstructorInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorInfoMutation) OldPHONENUMBER(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPHONENUMBER is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPHONENUMBER requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPHONENUMBER: %w", err)
	}
	return oldValue.PHONENUMBER, nil
}

// AddPHONENUMBER adds i to PHONENUMBER.
func (m *InstructorInfoMutation) AddPHONENUMBER(i int) {
	if m.add_PHONENUMBER != nil {
		*m.add_PHONENUMBER += i
	} else {
		m.add_PHONENUMBER = &i
	}
}

// AddedPHONENUMBER returns the value that was added to the PHONENUMBER field in this mutation.
func (m *InstructorInfoMutation) AddedPHONENUMBER() (r int, exists bool) {
	v := m.add_PHONENUMBER
	if v == nil {
		return
	}
	return *v, true
}

// ResetPHONENUMBER reset all changes of the "PHONENUMBER" field.
func (m *InstructorInfoMutation) ResetPHONENUMBER() {
	m._PHONENUMBER = nil
	m.add_PHONENUMBER = nil
}

// SetEMAIL sets the EMAIL field.
func (m *InstructorInfoMutation) SetEMAIL(s string) {
	m._EMAIL = &s
}

// EMAIL returns the EMAIL value in the mutation.
func (m *InstructorInfoMutation) EMAIL() (r string, exists bool) {
	v := m._EMAIL
	if v == nil {
		return
	}
	return *v, true
}

// OldEMAIL returns the old EMAIL value of the InstructorInfo.
// If the InstructorInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorInfoMutation) OldEMAIL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEMAIL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEMAIL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEMAIL: %w", err)
	}
	return oldValue.EMAIL, nil
}

// ResetEMAIL reset all changes of the "EMAIL" field.
func (m *InstructorInfoMutation) ResetEMAIL() {
	m._EMAIL = nil
}

// SetPASSWORD sets the PASSWORD field.
func (m *InstructorInfoMutation) SetPASSWORD(s string) {
	m._PASSWORD = &s
}

// PASSWORD returns the PASSWORD value in the mutation.
func (m *InstructorInfoMutation) PASSWORD() (r string, exists bool) {
	v := m._PASSWORD
	if v == nil {
		return
	}
	return *v, true
}

// OldPASSWORD returns the old PASSWORD value of the InstructorInfo.
// If the InstructorInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorInfoMutation) OldPASSWORD(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPASSWORD is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPASSWORD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPASSWORD: %w", err)
	}
	return oldValue.PASSWORD, nil
}

// ResetPASSWORD reset all changes of the "PASSWORD" field.
func (m *InstructorInfoMutation) ResetPASSWORD() {
	m._PASSWORD = nil
}

// SetTitleID sets the title edge to Title by id.
func (m *InstructorInfoMutation) SetTitleID(id int) {
	m.title = &id
}

// ClearTitle clears the title edge to Title.
func (m *InstructorInfoMutation) ClearTitle() {
	m.clearedtitle = true
}

// TitleCleared returns if the edge title was cleared.
func (m *InstructorInfoMutation) TitleCleared() bool {
	return m.clearedtitle
}

// TitleID returns the title id in the mutation.
func (m *InstructorInfoMutation) TitleID() (id int, exists bool) {
	if m.title != nil {
		return *m.title, true
	}
	return
}

// TitleIDs returns the title ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TitleID instead. It exists only for internal usage by the builders.
func (m *InstructorInfoMutation) TitleIDs() (ids []int) {
	if id := m.title; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTitle reset all changes of the "title" edge.
func (m *InstructorInfoMutation) ResetTitle() {
	m.title = nil
	m.clearedtitle = false
}

// SetInstructorroomID sets the instructorroom edge to InstructorRoom by id.
func (m *InstructorInfoMutation) SetInstructorroomID(id int) {
	m.instructorroom = &id
}

// ClearInstructorroom clears the instructorroom edge to InstructorRoom.
func (m *InstructorInfoMutation) ClearInstructorroom() {
	m.clearedinstructorroom = true
}

// InstructorroomCleared returns if the edge instructorroom was cleared.
func (m *InstructorInfoMutation) InstructorroomCleared() bool {
	return m.clearedinstructorroom
}

// InstructorroomID returns the instructorroom id in the mutation.
func (m *InstructorInfoMutation) InstructorroomID() (id int, exists bool) {
	if m.instructorroom != nil {
		return *m.instructorroom, true
	}
	return
}

// InstructorroomIDs returns the instructorroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InstructorroomID instead. It exists only for internal usage by the builders.
func (m *InstructorInfoMutation) InstructorroomIDs() (ids []int) {
	if id := m.instructorroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstructorroom reset all changes of the "instructorroom" edge.
func (m *InstructorInfoMutation) ResetInstructorroom() {
	m.instructorroom = nil
	m.clearedinstructorroom = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *InstructorInfoMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *InstructorInfoMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *InstructorInfoMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *InstructorInfoMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *InstructorInfoMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *InstructorInfoMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddInstructorIDs adds the instructor edge to Course by ids.
func (m *InstructorInfoMutation) AddInstructorIDs(ids ...int) {
	if m.instructor == nil {
		m.instructor = make(map[int]struct{})
	}
	for i := range ids {
		m.instructor[ids[i]] = struct{}{}
	}
}

// RemoveInstructorIDs removes the instructor edge to Course by ids.
func (m *InstructorInfoMutation) RemoveInstructorIDs(ids ...int) {
	if m.removedinstructor == nil {
		m.removedinstructor = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstructor[ids[i]] = struct{}{}
	}
}

// RemovedInstructor returns the removed ids of instructor.
func (m *InstructorInfoMutation) RemovedInstructorIDs() (ids []int) {
	for id := range m.removedinstructor {
		ids = append(ids, id)
	}
	return
}

// InstructorIDs returns the instructor ids in the mutation.
func (m *InstructorInfoMutation) InstructorIDs() (ids []int) {
	for id := range m.instructor {
		ids = append(ids, id)
	}
	return
}

// ResetInstructor reset all changes of the "instructor" edge.
func (m *InstructorInfoMutation) ResetInstructor() {
	m.instructor = nil
	m.removedinstructor = nil
}

// Op returns the operation name.
func (m *InstructorInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InstructorInfo).
func (m *InstructorInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InstructorInfoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._NAME != nil {
		fields = append(fields, instructorinfo.FieldNAME)
	}
	if m._PHONENUMBER != nil {
		fields = append(fields, instructorinfo.FieldPHONENUMBER)
	}
	if m._EMAIL != nil {
		fields = append(fields, instructorinfo.FieldEMAIL)
	}
	if m._PASSWORD != nil {
		fields = append(fields, instructorinfo.FieldPASSWORD)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InstructorInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instructorinfo.FieldNAME:
		return m.NAME()
	case instructorinfo.FieldPHONENUMBER:
		return m.PHONENUMBER()
	case instructorinfo.FieldEMAIL:
		return m.EMAIL()
	case instructorinfo.FieldPASSWORD:
		return m.PASSWORD()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InstructorInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instructorinfo.FieldNAME:
		return m.OldNAME(ctx)
	case instructorinfo.FieldPHONENUMBER:
		return m.OldPHONENUMBER(ctx)
	case instructorinfo.FieldEMAIL:
		return m.OldEMAIL(ctx)
	case instructorinfo.FieldPASSWORD:
		return m.OldPASSWORD(ctx)
	}
	return nil, fmt.Errorf("unknown InstructorInfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstructorInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instructorinfo.FieldNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNAME(v)
		return nil
	case instructorinfo.FieldPHONENUMBER:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPHONENUMBER(v)
		return nil
	case instructorinfo.FieldEMAIL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEMAIL(v)
		return nil
	case instructorinfo.FieldPASSWORD:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPASSWORD(v)
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InstructorInfoMutation) AddedFields() []string {
	var fields []string
	if m.add_PHONENUMBER != nil {
		fields = append(fields, instructorinfo.FieldPHONENUMBER)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InstructorInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case instructorinfo.FieldPHONENUMBER:
		return m.AddedPHONENUMBER()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstructorInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case instructorinfo.FieldPHONENUMBER:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPHONENUMBER(v)
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InstructorInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InstructorInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstructorInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InstructorInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InstructorInfoMutation) ResetField(name string) error {
	switch name {
	case instructorinfo.FieldNAME:
		m.ResetNAME()
		return nil
	case instructorinfo.FieldPHONENUMBER:
		m.ResetPHONENUMBER()
		return nil
	case instructorinfo.FieldEMAIL:
		m.ResetEMAIL()
		return nil
	case instructorinfo.FieldPASSWORD:
		m.ResetPASSWORD()
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InstructorInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.title != nil {
		edges = append(edges, instructorinfo.EdgeTitle)
	}
	if m.instructorroom != nil {
		edges = append(edges, instructorinfo.EdgeInstructorroom)
	}
	if m.department != nil {
		edges = append(edges, instructorinfo.EdgeDepartment)
	}
	if m.instructor != nil {
		edges = append(edges, instructorinfo.EdgeInstructor)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InstructorInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instructorinfo.EdgeTitle:
		if id := m.title; id != nil {
			return []ent.Value{*id}
		}
	case instructorinfo.EdgeInstructorroom:
		if id := m.instructorroom; id != nil {
			return []ent.Value{*id}
		}
	case instructorinfo.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case instructorinfo.EdgeInstructor:
		ids := make([]ent.Value, 0, len(m.instructor))
		for id := range m.instructor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InstructorInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinstructor != nil {
		edges = append(edges, instructorinfo.EdgeInstructor)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InstructorInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instructorinfo.EdgeInstructor:
		ids := make([]ent.Value, 0, len(m.removedinstructor))
		for id := range m.removedinstructor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InstructorInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtitle {
		edges = append(edges, instructorinfo.EdgeTitle)
	}
	if m.clearedinstructorroom {
		edges = append(edges, instructorinfo.EdgeInstructorroom)
	}
	if m.cleareddepartment {
		edges = append(edges, instructorinfo.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InstructorInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case instructorinfo.EdgeTitle:
		return m.clearedtitle
	case instructorinfo.EdgeInstructorroom:
		return m.clearedinstructorroom
	case instructorinfo.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InstructorInfoMutation) ClearEdge(name string) error {
	switch name {
	case instructorinfo.EdgeTitle:
		m.ClearTitle()
		return nil
	case instructorinfo.EdgeInstructorroom:
		m.ClearInstructorroom()
		return nil
	case instructorinfo.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InstructorInfoMutation) ResetEdge(name string) error {
	switch name {
	case instructorinfo.EdgeTitle:
		m.ResetTitle()
		return nil
	case instructorinfo.EdgeInstructorroom:
		m.ResetInstructorroom()
		return nil
	case instructorinfo.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case instructorinfo.EdgeInstructor:
		m.ResetInstructor()
		return nil
	}
	return fmt.Errorf("unknown InstructorInfo edge %s", name)
}

// InstructorRoomMutation represents an operation that mutate the InstructorRooms
// nodes in the graph.
type InstructorRoomMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_ROOM                  *string
	_BUILDING              *string
	clearedFields          map[string]struct{}
	instructorinfos        map[int]struct{}
	removedinstructorinfos map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*InstructorRoom, error)
}

var _ ent.Mutation = (*InstructorRoomMutation)(nil)

// instructorroomOption allows to manage the mutation configuration using functional options.
type instructorroomOption func(*InstructorRoomMutation)

// newInstructorRoomMutation creates new mutation for $n.Name.
func newInstructorRoomMutation(c config, op Op, opts ...instructorroomOption) *InstructorRoomMutation {
	m := &InstructorRoomMutation{
		config:        c,
		op:            op,
		typ:           TypeInstructorRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstructorRoomID sets the id field of the mutation.
func withInstructorRoomID(id int) instructorroomOption {
	return func(m *InstructorRoomMutation) {
		var (
			err   error
			once  sync.Once
			value *InstructorRoom
		)
		m.oldValue = func(ctx context.Context) (*InstructorRoom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstructorRoom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstructorRoom sets the old InstructorRoom of the mutation.
func withInstructorRoom(node *InstructorRoom) instructorroomOption {
	return func(m *InstructorRoomMutation) {
		m.oldValue = func(context.Context) (*InstructorRoom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstructorRoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstructorRoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InstructorRoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetROOM sets the ROOM field.
func (m *InstructorRoomMutation) SetROOM(s string) {
	m._ROOM = &s
}

// ROOM returns the ROOM value in the mutation.
func (m *InstructorRoomMutation) ROOM() (r string, exists bool) {
	v := m._ROOM
	if v == nil {
		return
	}
	return *v, true
}

// OldROOM returns the old ROOM value of the InstructorRoom.
// If the InstructorRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorRoomMutation) OldROOM(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldROOM is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldROOM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldROOM: %w", err)
	}
	return oldValue.ROOM, nil
}

// ResetROOM reset all changes of the "ROOM" field.
func (m *InstructorRoomMutation) ResetROOM() {
	m._ROOM = nil
}

// SetBUILDING sets the BUILDING field.
func (m *InstructorRoomMutation) SetBUILDING(s string) {
	m._BUILDING = &s
}

// BUILDING returns the BUILDING value in the mutation.
func (m *InstructorRoomMutation) BUILDING() (r string, exists bool) {
	v := m._BUILDING
	if v == nil {
		return
	}
	return *v, true
}

// OldBUILDING returns the old BUILDING value of the InstructorRoom.
// If the InstructorRoom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InstructorRoomMutation) OldBUILDING(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBUILDING is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBUILDING requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBUILDING: %w", err)
	}
	return oldValue.BUILDING, nil
}

// ResetBUILDING reset all changes of the "BUILDING" field.
func (m *InstructorRoomMutation) ResetBUILDING() {
	m._BUILDING = nil
}

// AddInstructorinfoIDs adds the instructorinfos edge to InstructorInfo by ids.
func (m *InstructorRoomMutation) AddInstructorinfoIDs(ids ...int) {
	if m.instructorinfos == nil {
		m.instructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.instructorinfos[ids[i]] = struct{}{}
	}
}

// RemoveInstructorinfoIDs removes the instructorinfos edge to InstructorInfo by ids.
func (m *InstructorRoomMutation) RemoveInstructorinfoIDs(ids ...int) {
	if m.removedinstructorinfos == nil {
		m.removedinstructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstructorinfos[ids[i]] = struct{}{}
	}
}

// RemovedInstructorinfos returns the removed ids of instructorinfos.
func (m *InstructorRoomMutation) RemovedInstructorinfosIDs() (ids []int) {
	for id := range m.removedinstructorinfos {
		ids = append(ids, id)
	}
	return
}

// InstructorinfosIDs returns the instructorinfos ids in the mutation.
func (m *InstructorRoomMutation) InstructorinfosIDs() (ids []int) {
	for id := range m.instructorinfos {
		ids = append(ids, id)
	}
	return
}

// ResetInstructorinfos reset all changes of the "instructorinfos" edge.
func (m *InstructorRoomMutation) ResetInstructorinfos() {
	m.instructorinfos = nil
	m.removedinstructorinfos = nil
}

// Op returns the operation name.
func (m *InstructorRoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InstructorRoom).
func (m *InstructorRoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InstructorRoomMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._ROOM != nil {
		fields = append(fields, instructorroom.FieldROOM)
	}
	if m._BUILDING != nil {
		fields = append(fields, instructorroom.FieldBUILDING)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InstructorRoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instructorroom.FieldROOM:
		return m.ROOM()
	case instructorroom.FieldBUILDING:
		return m.BUILDING()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InstructorRoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instructorroom.FieldROOM:
		return m.OldROOM(ctx)
	case instructorroom.FieldBUILDING:
		return m.OldBUILDING(ctx)
	}
	return nil, fmt.Errorf("unknown InstructorRoom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstructorRoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instructorroom.FieldROOM:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetROOM(v)
		return nil
	case instructorroom.FieldBUILDING:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBUILDING(v)
		return nil
	}
	return fmt.Errorf("unknown InstructorRoom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InstructorRoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InstructorRoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InstructorRoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InstructorRoom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InstructorRoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InstructorRoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstructorRoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InstructorRoom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InstructorRoomMutation) ResetField(name string) error {
	switch name {
	case instructorroom.FieldROOM:
		m.ResetROOM()
		return nil
	case instructorroom.FieldBUILDING:
		m.ResetBUILDING()
		return nil
	}
	return fmt.Errorf("unknown InstructorRoom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InstructorRoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instructorinfos != nil {
		edges = append(edges, instructorroom.EdgeInstructorinfos)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InstructorRoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instructorroom.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.instructorinfos))
		for id := range m.instructorinfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InstructorRoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinstructorinfos != nil {
		edges = append(edges, instructorroom.EdgeInstructorinfos)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InstructorRoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instructorroom.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.removedinstructorinfos))
		for id := range m.removedinstructorinfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InstructorRoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InstructorRoomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InstructorRoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InstructorRoom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InstructorRoomMutation) ResetEdge(name string) error {
	switch name {
	case instructorroom.EdgeInstructorinfos:
		m.ResetInstructorinfos()
		return nil
	}
	return fmt.Errorf("unknown InstructorRoom edge %s", name)
}

// SubjectMutation represents an operation that mutate the Subjects
// nodes in the graph.
type SubjectMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Subject_name  *string
	clearedFields  map[string]struct{}
	subject        map[int]struct{}
	removedsubject map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Subject, error)
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows to manage the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for $n.Name.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the id field of the mutation.
func withSubjectID(id int) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SubjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSubjectName sets the Subject_name field.
func (m *SubjectMutation) SetSubjectName(s string) {
	m._Subject_name = &s
}

// SubjectName returns the Subject_name value in the mutation.
func (m *SubjectMutation) SubjectName() (r string, exists bool) {
	v := m._Subject_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectName returns the old Subject_name value of the Subject.
// If the Subject object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SubjectMutation) OldSubjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubjectName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectName: %w", err)
	}
	return oldValue.SubjectName, nil
}

// ResetSubjectName reset all changes of the "Subject_name" field.
func (m *SubjectMutation) ResetSubjectName() {
	m._Subject_name = nil
}

// AddSubjectIDs adds the subject edge to Course by ids.
func (m *SubjectMutation) AddSubjectIDs(ids ...int) {
	if m.subject == nil {
		m.subject = make(map[int]struct{})
	}
	for i := range ids {
		m.subject[ids[i]] = struct{}{}
	}
}

// RemoveSubjectIDs removes the subject edge to Course by ids.
func (m *SubjectMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubject == nil {
		m.removedsubject = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsubject[ids[i]] = struct{}{}
	}
}

// RemovedSubject returns the removed ids of subject.
func (m *SubjectMutation) RemovedSubjectIDs() (ids []int) {
	for id := range m.removedsubject {
		ids = append(ids, id)
	}
	return
}

// SubjectIDs returns the subject ids in the mutation.
func (m *SubjectMutation) SubjectIDs() (ids []int) {
	for id := range m.subject {
		ids = append(ids, id)
	}
	return
}

// ResetSubject reset all changes of the "subject" edge.
func (m *SubjectMutation) ResetSubject() {
	m.subject = nil
	m.removedsubject = nil
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Subject_name != nil {
		fields = append(fields, subject.FieldSubjectName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldSubjectName:
		return m.SubjectName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldSubjectName:
		return m.OldSubjectName(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldSubjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectName(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SubjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldSubjectName:
		m.ResetSubjectName()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subject != nil {
		edges = append(edges, subject.EdgeSubject)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeSubject:
		ids := make([]ent.Value, 0, len(m.subject))
		for id := range m.subject {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubject != nil {
		edges = append(edges, subject.EdgeSubject)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeSubject:
		ids := make([]ent.Value, 0, len(m.removedsubject))
		for id := range m.removedsubject {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// TitleMutation represents an operation that mutate the Titles
// nodes in the graph.
type TitleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_TITLE                 *string
	clearedFields          map[string]struct{}
	instructorinfos        map[int]struct{}
	removedinstructorinfos map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Title, error)
}

var _ ent.Mutation = (*TitleMutation)(nil)

// titleOption allows to manage the mutation configuration using functional options.
type titleOption func(*TitleMutation)

// newTitleMutation creates new mutation for $n.Name.
func newTitleMutation(c config, op Op, opts ...titleOption) *TitleMutation {
	m := &TitleMutation{
		config:        c,
		op:            op,
		typ:           TypeTitle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTitleID sets the id field of the mutation.
func withTitleID(id int) titleOption {
	return func(m *TitleMutation) {
		var (
			err   error
			once  sync.Once
			value *Title
		)
		m.oldValue = func(ctx context.Context) (*Title, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Title.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTitle sets the old Title of the mutation.
func withTitle(node *Title) titleOption {
	return func(m *TitleMutation) {
		m.oldValue = func(context.Context) (*Title, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TitleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TitleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TitleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTITLE sets the TITLE field.
func (m *TitleMutation) SetTITLE(s string) {
	m._TITLE = &s
}

// TITLE returns the TITLE value in the mutation.
func (m *TitleMutation) TITLE() (r string, exists bool) {
	v := m._TITLE
	if v == nil {
		return
	}
	return *v, true
}

// OldTITLE returns the old TITLE value of the Title.
// If the Title object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TitleMutation) OldTITLE(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTITLE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTITLE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTITLE: %w", err)
	}
	return oldValue.TITLE, nil
}

// ResetTITLE reset all changes of the "TITLE" field.
func (m *TitleMutation) ResetTITLE() {
	m._TITLE = nil
}

// AddInstructorinfoIDs adds the instructorinfos edge to InstructorInfo by ids.
func (m *TitleMutation) AddInstructorinfoIDs(ids ...int) {
	if m.instructorinfos == nil {
		m.instructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.instructorinfos[ids[i]] = struct{}{}
	}
}

// RemoveInstructorinfoIDs removes the instructorinfos edge to InstructorInfo by ids.
func (m *TitleMutation) RemoveInstructorinfoIDs(ids ...int) {
	if m.removedinstructorinfos == nil {
		m.removedinstructorinfos = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstructorinfos[ids[i]] = struct{}{}
	}
}

// RemovedInstructorinfos returns the removed ids of instructorinfos.
func (m *TitleMutation) RemovedInstructorinfosIDs() (ids []int) {
	for id := range m.removedinstructorinfos {
		ids = append(ids, id)
	}
	return
}

// InstructorinfosIDs returns the instructorinfos ids in the mutation.
func (m *TitleMutation) InstructorinfosIDs() (ids []int) {
	for id := range m.instructorinfos {
		ids = append(ids, id)
	}
	return
}

// ResetInstructorinfos reset all changes of the "instructorinfos" edge.
func (m *TitleMutation) ResetInstructorinfos() {
	m.instructorinfos = nil
	m.removedinstructorinfos = nil
}

// Op returns the operation name.
func (m *TitleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Title).
func (m *TitleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TitleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._TITLE != nil {
		fields = append(fields, title.FieldTITLE)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TitleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case title.FieldTITLE:
		return m.TITLE()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TitleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case title.FieldTITLE:
		return m.OldTITLE(ctx)
	}
	return nil, fmt.Errorf("unknown Title field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case title.FieldTITLE:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTITLE(v)
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TitleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TitleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Title numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TitleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TitleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TitleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Title nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TitleMutation) ResetField(name string) error {
	switch name {
	case title.FieldTITLE:
		m.ResetTITLE()
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TitleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instructorinfos != nil {
		edges = append(edges, title.EdgeInstructorinfos)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TitleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.instructorinfos))
		for id := range m.instructorinfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TitleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinstructorinfos != nil {
		edges = append(edges, title.EdgeInstructorinfos)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TitleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeInstructorinfos:
		ids := make([]ent.Value, 0, len(m.removedinstructorinfos))
		for id := range m.removedinstructorinfos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TitleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TitleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TitleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Title unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TitleMutation) ResetEdge(name string) error {
	switch name {
	case title.EdgeInstructorinfos:
		m.ResetInstructorinfos()
		return nil
	}
	return fmt.Errorf("unknown Title edge %s", name)
}
